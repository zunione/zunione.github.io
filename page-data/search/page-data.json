{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"🚀 들어가며 NASA cFS 팀은 일반 사용자를 위한 교육 세션을 제공한다. 교육 목록은 cFS 공식 웹사이트(클릭)에서 확인할 수 있다.  다섯 개의 교육 과정 중 FSW101, CFS101, CFS102는 온라인 세션이며, CFS201, CFS202는 NASA GSFC에서 진행하는 오프라인 세션이다. 그 중에서도 CFS-101이 Github에 오픈소스…","fields":{"slug":"/cfs-101/"},"frontmatter":{"date":"January 09, 2026","title":"[cFS] CFS-101(1): cFE Core Apps 빌드 및 실행","tags":["nasa-cfs","fsw"]},"rawMarkdownBody":"\n## 🚀 들어가며\n\nNASA cFS 팀은 일반 사용자를 위한 교육 세션을 제공한다. 교육 목록은 [cFS 공식 웹사이트(클릭)](https://etd.gsfc.nasa.gov/capabilities/core-flight-system/training/)에서 확인할 수 있다.\n\n![cFS Training](image.png)\n\n다섯 개의 교육 과정 중 FSW101, CFS101, CFS102는 온라인 세션이며, CFS201, CFS202는 NASA GSFC에서 진행하는 오프라인 세션이다.\n\n그 중에서도 CFS-101이 Github에 오픈소스로 공개되어 있어 학습에 활용해 보려 한다.\n\n## 📚 CFS-101 교육자료 다운로드\n\n[CFS-101 Github repository(클릭)](https://github.com/nasa/CFS-101)에서 프로젝트를 다운로드한다.\n\n**주의**: 프로젝트 크기가 큰 편이기 때문에 clone 시에 시간이 굉장히 오래 걸린다. 꼭 사진처럼 **다운로드**하는 것을 권장한다.\n\n![Download project from Github](image-1.png)\n\n약 5분 정도 소요되며, 이후 `CFS-101-master.zip` 파일의 압축을 풀고 파일이 잘 다운로드되었는지 확인한다. 이후 `README.txt` 파일의 지시를 따라 진행한다.\n\n![CFS-101 files](image-2.png)\n\n## 🤖 VirtualBox 다운로드\n\n> 반드시 윈도우 PC에서 진행해야 합니다. MacOS에서는 CFS-101 컨테이너가 정상 작동하지 않습니다.\n\nCFS-101은 모두에게 동일한 환경을 제공하기 위해 VirtualBox를 통한 VM을 사용한다. 먼저 [Oracle VirtualBox 다운로드 페이지(클릭)](https://www.virtualbox.org/)에 접속한다.\n\n![Oracle VirtualBox download](image-3.png)\n\nWindows hosts 패키지를 다운로드한다.\n\n![Windows hosts package](image-4.png)\n\n`VirtualBox-7.2.4-170995-Win.exe` 파일이 다운로드되면 해당 파일을 실행하고 설치 마법사의 지시에 따라 진행한다. VirtualBox 다운로드 과정까지 작성하기에는 글이 길어질 것 같아 생략하니 필요하다면 구글링 해보시길😉\n\n## ⚡ VM Container 실행\n\n컨테이너 파일을 압축 해제하기 위해서는 반디집이나 `7-Zip` 툴을 설치해야 한다. 나는 반디집으로 진행했는데, 공식 문서에서는 `7-Zip`을 권장하고 있다.\n\n![CFS-101-VM.7z.001 압축 해제](image-8.png)\n\n`CFS-101-VM.zip.001` 더블 클릭 후 반디집 내에서 '풀기'를 클릭하면 자동으로 압축 해제가 진행된다.\n\n`7-Zip`을 사용하는 경우, `README.txt`의 설명대로 `CFS-101-VM.zip.001`을 우클릭하고 *`7-Zip` → Extract to \"CFS-101-VM\"* 을 차례로 선택해 압축을 해제한다.\n\n![Start VirtualBox](image-10.png)\n\nVirtualBox를 실행하고 'Open' 버튼을 클릭한다.\n\n![Select VirtualBox Machine Definition](image-11.png)\n\n아까 압축 해제한 폴더에 들어가 `CFS-101.vbox`라는 이름의 VirtualBox Machine Definition 파일을 열어 준다.\n\n![Start CFS-101 container](image-12.png)\n\n시작 버튼을 클릭하면 컨테이너가 정상 실행된다.\n\n## 🚶 CFS-101 시작하기\n\n### 교재 파일 압축 해제\n\n`CFS-101-master` 폴더 내의 `CFS-101-Guide.7z` 파일도 마찬가지로 압축 해제한다. 이때는 반디집, 7-Zip, 윈도우 11 기본 압축 툴 모두 사용 가능하다.\n\n![CFS-101.html](image-13.png)\n\n`CFS-101.html` 파일을 열면 CFS-101 Guide 웹 페이지가 나타난다.\n\n![CFS-101 Training Guide](image-14.png)\n\n### VM 유저 로그인\n\n![Username dev](image-15.png)\n\n`dev` 유저의 비밀번호 `cfs101!!`을 입력하여 로그인한다.\n\n## ▶️ cFE Core 실행\n\n컨테이너에 성공적으로 접속했다면 상단의 터미널 아이콘을 눌러 터미널을 열어 준다.\n\n![Open CentOS terminal](image-17.png)\n\n### Set Variables\n\n다음 명령어로 데모 프로젝트 위치로 이동하고, cFS를 실행하기 위한 변수들을 설정한다.\n\n```bash\ncd /home/dev/Training_workspace/CFS-101\nsource setvars.sh\n```\n\n### Build executable\n\n![Contents of CFS-101](image-18.png)\n\nCFS-101 내부의 파일 목록을 살펴보면 `Makefile`이 있다. 이 `Makefile`을 사용하여 cFS를 빌드한다.\n\n```bash\nmake prep\nmake\nmake install\n```\n\n![Generated build directory](image-19.png)\n\n빌드 후에는 사진과 같이 `build` 디렉토리가 생성된다. `build` 안에는 실행 파일과 실행에 필요한 스타트업 파일들이 위치한다.\n\n### Execute core ELF file\n\n다음 명령어로 cFE core를 실행한다.\n\n```bash\ncd /home/dev/Training_workspace/CFS-101/build/exe/cpu1\n./core-cpu1\n```\n\n## 🧐 cFS 동작 살펴보기\n\n성공적으로 `core-cpu1` 파일을 실행했다면 다음과 유사한 로그가 출력되었을 것이다.\n\n    CFE_PSP: Default Reset Type = PO\n    CFE_PSP: Default Reset SubType = 1\n    CFE_PSP: Default CPU ID = 1\n    CFE_PSP: Default Spacecraft ID = 42\n    CFE_PSP: Default CPU Name: cpu1\n    CFE_PSP: Starting the cFE with a POWER ON reset.\n    CFE_PSP: Clearing out CFE CDS Shared memory segment.\n    CFE_PSP: Clearing out CFE Reset Shared memory segment.\n    CFE_PSP: Clearing out CFE User Reserved Shared memory segment.\n    2028-156-18:56:44.85300 POWER ON RESET due to Power Cycle (Power Cycle).\n    2028-156-18:56:44.85304 ES Startup: CFE_ES_Main in EARLY_INIT state\n    CFE_PSP: CFE_PSP_AttachExceptions Called\n    2028-156-18:56:44.85314 ES Startup: CFE_ES_Main entering CORE_STARTUP state\n    2028-156-18:56:44.85314 ES Startup: Starting Object Creation calls.\n    2028-156-18:56:44.85315 ES Startup: Calling CFE_ES_CDSEarlyInit\n    2028-156-18:56:44.85324 ES Startup: Calling CFE_EVS_EarlyInit\n    2028-156-18:56:44.85328 Event Log cleared following power-on reset\n    2028-156-18:56:44.85329 ES Startup: Calling CFE_SB_EarlyInit\n    2028-156-18:56:44.85338 ES Startup: Calling CFE_TIME_EarlyInit\n    1980-012-14:03:20.00000 ES Startup: Calling CFE_TBL_EarlyInit\n    1980-012-14:03:20.00015 ES Startup: Calling CFE_FS_EarlyInit\n    1980-012-14:03:20.00046 ES Startup: Core App: CFE_EVS created. App ID: 0\n    EVS Port1 42/1/CFE_EVS 14: No subscribers for MsgId 0x808,sender CFE_EVS\n    EVS Port1 42/1/CFE_EVS 1: cFE EVS Initialized. cFE Version 6.5.0.0\n    1980-012-14:03:20.05162 ES Startup: Core App: CFE_SB created. App ID: 1\n    1980-012-14:03:20.05165 SB:Registered 4 events for filtering\n    EVS Port1 42/1/CFE_SB 14: No subscribers for MsgId 0x808,sender CFE_SB\n    EVS Port1 42/1/CFE_SB 1: cFE SB Initialized\n    1980-012-14:03:20.10238 ES Startup: Core App: CFE_ES created. App ID: 2\n    EVS Port1 42/1/CFE_SB 14: No subscribers for MsgId 0x808,sender CFE_ES\n    EVS Port1 42/1/CFE_ES 1: cFE ES Initialized\n    EVS Port1 42/1/CFE_SB 14: No subscribers for MsgId 0x808,sender CFE_ES\n    EVS Port1 42/1/CFE_ES 2: Versions:cFE 6.5.0.0, OSAL 4.2.1.0, PSP 1.3.0.0, chksm 10387\n    EVS Port1 42/1/CFE_SB 14: No subscribers for MsgId 0x808,sender CFE_ES\n    EVS Port1 42/1/CFE_ES 91: Mission error/unknown.cfs101, error/unknown, error/unknown\n    EVS Port1 42/1/CFE_ES 92: Build 201806051353 dev@localhost.localdomain\n    1980-012-14:03:20.15302 ES Startup: Core App: CFE_TIME created. App ID: 3\n    EVS Port1 42/1/CFE_TIME 1: cFE TIME Initialized\n    1980-012-14:03:20.20345 ES Startup: Core App: CFE_TBL created. App ID: 4\n    EVS Port1 42/1/CFE_TBL 1: cFE TBL Initialized.  cFE Version 6.5.0.0\n    1980-012-14:03:20.25362 ES Startup: Finished ES CreateObject table entries.\n    1980-012-14:03:20.25363 ES Startup: CFE_ES_Main entering CORE_READY state\n    1980-012-14:03:20.25367 ES Startup: Opened ES App Startup file: /cf/cfe_es_startup.scr\n    1980-012-14:03:20.25426 ES Startup: Loading shared library: /cf/sample_lib.so\n    SAMPLE Lib Initialized.  Version 1.0.0.01980-012-14:03:20.25450 ES Startup: Loading file: /cf/sample_app.so, APP: SAMPLE_APP\n    1980-012-14:03:20.25470 ES Startup: SAMPLE_APP loaded and created\n    1980-012-14:03:20.25481 ES Startup: Loading shared library: /cf/io_lib.so\n    1980-012-14:03:20.25496 IO Lib Initialized.  Version 1.0.0.0\n    1980-012-14:03:20.25510 ES Startup: Loading file: /cf/ci.so, APP: CI\n    1980-012-14:03:20.25521 ES Startup: CI loaded and created\n    1980-012-14:03:20.25532 ES Startup: Loading file: /cf/to.so, APP: TO\n    1980-012-14:03:20.25542 ES Startup: TO loaded and created\n    1980-012-14:03:20.25554 ES Startup: Loading file: /cf/sch.so, APP: SCH\n    1980-012-14:03:20.25572 ES Startup: SCH loaded and created\n    EVS Port1 42/1/SAMPLE_APP 4: SAMPLE: RESET command\n    EVS Port1 42/1/SAMPLE_APP 1: SAMPLE App Initialized. Version 1.0.0.0\n    EVS Port1 42/1/CI 2: Application initialized\n    EVS Port1 42/1/TO 2: Application initialized\n    EVS Port1 42/1/SCH 1: SCH Initialized. Version 2.2.1.0\n    1980-012-14:03:20.30586 ES Startup: CFE_ES_Main entering OPERATIONAL state\n    EVS Port1 42/1/CFE_TIME 21: Stop FLYWHEEL\n    EVS Port1 42/1/SCH 18: Multiple slots processed: slot = 96, count = 5\n    EVS Port1 42/1/SCH 18: Multiple slots processed: slot = 96, count = 5\n    . . . .\n\n### 1. PSP 초기화\n\n    CFE_PSP: Starting the cFE with a POWER ON reset.\n    CFE_PSP: Clearing out CFE CDS Shared memory segment.\n\nPSP가 먼저 리셋 타입을 결정하고, 공유 메모리 영역을 초기화한다.\n\n리셋 타입은 `POWER ON reset`과 `PROCESSOR Reset`으로 구별되고, 각 리셋 타입에 따라 메모리 초기화 방식이 달라진다. Power On reset은 모든 공유 메모리를 완전히 초기화하는 cold boot이고, Processor Reset은 일부 중요 데이터(CDS 등)를 보존하면서 재시작하는 warm boot이다.\n\n```c\n/* psp/fsw/pc-linux/src/cfe_psp_start.c */\n\nvoid CFE_PSP_DisplayUsage(char *Name)\n{\n    printf(\"        -R [ --reset ] Reset Type is one of:\\n\");\n    printf(\"             PO   for Power On reset ( default )\\n\");\n    printf(\"             PR   for Processor Reset\\n\");\n}\n\nif (reset_type == CFE_PSP_RST_TYPE_PROCESSOR)\n{\n    OS_printf(\"CFE_PSP: Starting the cFE with a PROCESSOR reset.\\n\");\n}\nelse\n{\n    reset_type = CFE_PSP_RST_TYPE_POWERON;\n    OS_printf(\"CFE_PSP: Starting the cFE with a POWER ON reset.\\n\");\n}\n```\n\n### 2. Early Initialization\n\n    ES Startup: CFE_ES_Main in EARLY_INIT state\n    CFE_PSP: CFE_PSP_AttachExceptions Called\n    ES Startup: CFE_ES_Main entering CORE_STARTUP state\n    ES Startup: Calling CFE_ES_CDSEarlyInit\n    ES Startup: Calling CFE_EVS_EarlyInit\n    ES Startup: Calling CFE_SB_EarlyInit\n    ES Startup: Calling CFE_TIME_EarlyInit\n    ES Startup: Calling CFE_TBL_EarlyInit\n    ES Startup: Calling CFE_FS_EarlyInit\n\nExecutive Services(ES)가 가장 먼저 시작되어 예외 처리기를 연결한다. \n\n이후 각 core 서비스(CDS, EVS, SB, TIME, TBL, FS)의 기본 자료구조와 내부 데이터를 초기화한다. 이때 아직 스레드/태스크로 생성되지 않은 상태이다.\n\n### 3. Core Apps 생성\n\n    ES Startup: Core App: CFE_EVS created. App ID: 0\n    ES Startup: Core App: CFE_SB created. App ID: 1\n    ES Startup: Core App: CFE_ES created. App ID: 2\n    ES Startup: Core App: CFE_TIME created. App ID: 3\n    ES Startup: Core App: CFE_TBL created. App ID: 4\n\n각 core 서비스를 독립적인 스레드/태스크로 생성한다. 이제 각 서비스는 자신의 실행 컨텍스트를 가지게 된다.\n\n### 4. User Apps 로딩 (CORE_READY 상태)\n\n    ES Startup: CFE_ES_Main entering CORE_READY state\n    ES Startup: Opened ES App Startup file: /cf/cfe_es_startup.scr\n    ES Startup: Loading shared library: /cf/sample_lib.so\n    ES Startup: Loading file: /cf/sample_app.so, APP: SAMPLE_APP\n\n`/cf` 디렉토리에서 `cfe_es_startup.scr` 파일을 찾아 읽은 후, 같은 디렉토리에서 라이브러리와 애플리케이션들을 순차적으로 로드한다. \n\n`cfe_es_startup.scr`에는 미션 수행에 필요한 모듈이 기록되어 있으며, 유저가 구현한 mission-specific 애플리케이션을 자유롭게 추가할 수 있다.\n\n```\nCFE_LIB, cfe_assert,  CFE_Assert_LibInit, ASSERT_LIB,    0,   0,     0x0, 0;\nCFE_LIB, sample_lib,  SAMPLE_LIB_Init,    SAMPLE_LIB,    0,   0,     0x0, 0;\nCFE_APP, sample_app,  SAMPLE_APP_Main,    SAMPLE_APP,   50,   16384, 0x0, 0;\nCFE_APP, ci_lab,      CI_Lab_AppMain,     CI_LAB_APP,   60,   16384, 0x0, 0;\nCFE_APP, to_lab,      TO_Lab_AppMain,     TO_LAB_APP,   70,   16384, 0x0, 0;\nCFE_APP, sch_lab,     SCH_Lab_AppMain,    SCH_LAB_APP,  80,   16384, 0x0, 0;\n!\n! Startup script fields:\n! 1. Object Type      -- CFE_APP for an Application, or CFE_LIB for a library.\n! 2. Path/Filename    -- This is a cFE Virtual filename, not a vxWorks device/pathname\n! 3. Entry Point      -- This is the \"main\" function for Apps.\n! 4. CFE Name         -- The cFE name for the APP or Library\n! 5. Priority         -- This is the Priority of the App, not used for Library\n! 6. Stack Size       -- This is the Stack size for the App, not used for the Library\n! 7. Load Address     -- This is the Optional Load Address for the App or Library. Currently not implemented\n!                        so keep it at 0x0.\n! 8. Exception Action -- This is the Action the cFE should take if the App has an exception.\n!                        0        = Just restart the Application\n!                        Non-Zero = Do a cFE Processor Reset\n!\n! Other  Notes:\n! 1. The software will not try to parse anything after the first '!' character it sees. That\n!    is the End of File marker.\n! 2. Common Application file extensions:\n!    Linux = .so  ( ci.so )\n!    OS X  = .bundle  ( ci.bundle )\n!    Cygwin = .dll ( ci.dll )\n!    vxWorks = .o ( ci.o )\n!    RTEMS with S-record Loader = .s3r ( ci.s3r )\n!    RTEMS with CEXP Loader = .o ( ci.o )\n! 3. The filename field (2) no longer requires a fully-qualified filename; the path and extension\n!    may be omitted.  If omitted, the standard virtual path (/cf) and a platform-specific default\n!    extension will be used, which is derived from the build system.\n```\n\n### 5. 운영 모드 진입\n\n    ES Startup: CFE_ES_Main entering OPERATIONAL state\n\n## ✨ 마치며\n\n이전 포스팅에서 cFS의 구조를 살펴봤다면 이번에는 실습을 해 보았다!😎 특히 OSAL과 PSP는 프로젝트 진행 과정에서 많이 들여다봤었는데, CFE는 비교적 코드를 뜯어보지 않아서 이번 기회에 정리할 수 있었다.\n\nCFS-101은 이렇게 코어를 실행하는 것부터 시작해 GroundSystem으로 텔레메트리 송수신하기, 그리고 실제 애플리케이션 추가하기의 세 단계로 이루어져 있다.\n\n다음 포스팅에서는 GroundSystem을 실행해서 실제 위성체와 지상 기지국이 어떻게 통신하는지 알아볼 예정이다."},{"excerpt":"🚀 들어가며 최근 NASA의 Core Flight System(이하 cFS)을 접할 기회가 생겼다. cFS는 NASA가 실제 우주 미션에서 사용하고 2015년부터 오픈소스로 공개한 비행 소프트웨어 프레임워크이다. 수억 달러가 투입되는 우주 미션에서 비행 소프트웨어가 어떤 구조로 설계되고, 어떻게 신뢰성을 보장하는지 직접 살펴볼 수 있는 오픈소스가 존재한다…","fields":{"slug":"/cfs-basic-structure/"},"frontmatter":{"date":"January 07, 2026","title":"[cFS] NASA cFS 소프트웨어의 기본 구조","tags":["nasa-cfs","fsw"]},"rawMarkdownBody":"\n## 🚀 들어가며\n\n최근 NASA의 Core Flight System(이하 cFS)을 접할 기회가 생겼다. cFS는 NASA가 실제 우주 미션에서 사용하고 2015년부터 오픈소스로 공개한 비행 소프트웨어 프레임워크이다. \n\n수억 달러가 투입되는 우주 미션에서 비행 소프트웨어가 어떤 구조로 설계되고, 어떻게 신뢰성을 보장하는지 직접 살펴볼 수 있는 오픈소스가 존재한다는 것은 흔치 않은 기회라고 생각한다.\n\n이번 시리즈에서는 cFS를 자세히 살펴보고, 왜 많은 우주 프로젝트에서 채택되고 있는지, 실제 하드웨어에서 어떻게 활용될 수 있는지 공부할 예정이다.👊🏻 소스코드는 [NASA cFS 공식 Github(클릭)](https://github.com/nasa/cFS)에서 확인할 수 있다.\n\n이번 포스트에서는 다음 두 영상을 참고했다.\n\n### How NASA Recycles Software - What is cFS?\n\n> 썸네일을 클릭하면 유튜브 영상을 시청하실 수 있습니다.\n\n[![How NASA Recycles Software - What is cFS?](https://img.youtube.com/vi/kzVDcbVvNrU/mqdefault.jpg)](https://youtu.be/kzVDcbVvNrU?si=pFqT6iSEaSn2tqAr)\n\n### cFS Overview Presentation\n\n> 썸네일을 클릭하면 유튜브 영상을 시청하실 수 있습니다.\n\n[![cFS Overview Presentation](https://img.youtube.com/vi/u71pGsSgKeQ/maxresdefault.jpg)](https://youtu.be/u71pGsSgKeQ?si=IZpIMFtZlmp4k2P8)\n\n## ✈️ FSW(Flight Software)란?\n\nFlight Software(FSW)는 말 그대로 우주를 비행하는 소프트웨어로, 우주선의 On-Board Computer에서 실행되어 우주선에 전력이 공급되는 순간부터 작동을 시작한다. \n\nFSW는 실시간 운영체제(RTOS) 위에서 동작하면서, 우주선의 하드웨어를 제어하고 미션을 수행하는 모든 로직을 포함한다. 이를 보고 FSW를 우주선의 \"두뇌\"라고 표현하기도 한다.\n\n다만 Spacecraft Bus의 일부이거나 탑재 장비(Instrument)의 일부일 수 있는데, 우주선 본체의 제어뿐만 아니라 과학 장비나 관측 장비에도 들어갈 수 있다는 뜻이다.\n\n![](image.png)\n\n일반적인 임베디드 소프트웨어와 비교했을 때, FSW는 훨씬 더 높은 신뢰성과 안정성을 요구받는다. 한번 발사되면 물리적인 수리가 불가능하고, 통신 지연이 크며, 방사선 환경에서 동작해야 하기 때문이다.\n\n## 🌌 cFS 전체 구조\n\ncFS는 계층화와 추상화를 사용하여 재사용성을 높인 프레임워크이다. \n\n모듈 구성은 크게 cFE, OSAL, PSP로 이루어져 있다.\n\n![Core Flight Software Framework Architectural Layers](image-1.png)\n\nOSAL은 운영체제를 추상화하고, PSP는 각 플랫폼(하드웨어 + OS)마다 별도로 구현되어 플랫폼 종속적인 기능을 제공한다. '플랫폼'이 무엇인지 아직 감이 안 올 수 있는데, 설명할 예정이니 걱정하지 않아도 된다.😁\n\n이렇게 애플리케이션이 하드웨어와 운영체제로부터 분리되고, 그 위에서 cFE가 애플리케이션 실행 환경과 공통 서비스를 제공한다. 최상단의 애플리케이션들은 cFE API만을 사용하기 때문에 하드웨어나 OS를 전혀 신경 쓰지 않아도 된다.\n\n### OSAL (Operating System Abstraction Layer)\n\n![Operating System Abstraction Layer](image-2.png)\n\n각 RTOS는 태스크 생성, 동기화, 타이머 등 운영체제 기본 기능은 제공하지만 API가 모두 다르다. 예를 들어, 태스크 생성에 대한 API는 다음과 같다.\n\n- POSIX: `pthread_create()`\n- VxWorks: `taskSpawn()`\n- RTEMS: `rtems_task_create()`\n\n각기 다른 함수 때문에 OS를 바꾸려면 코드를 대량으로 수정해야 한다. OSAL은 이를 추상화하여 통일된 API를 제공하는 방법으로 문제를 해결한다.\n\n간단하게 태스크를 종료하는 API로 알아보면, 운영체제별로 다음과 같이 별도 구현되어 있다.\n\n```c\n/* osal/src/os/posix/src/os-impl-tasks.c */\n\nvoid OS_TaskExit_Impl()\n{\n  pthread_exit(NULL);\n}\n```\n\n```c\n/* osal/src/os/vxworks/src/os-impl-tasks.c */\n\nvoid OS_TaskExit_Impl()\n{\n  taskExit(0);\n}\n```\n\n```c\n/* osal/src/os/rtems/src/os-impl-tasks.c */\n\nvoid OS_TaskExit_Impl()\n{\n  rtems_task_delete(RTEMS_SELF);\n}\n```\n\n이렇듯 OSAL은 운영체제에 따라 내부적으로 적합한 API를 선택하기 때문에 이식성이 좋고, 컴파일 툴체인만 교체하면 별도의 코드 수정 없이 소프트웨어를 사용할 수 있다.\n\n### PSP (Platform Support Package)\n\n![Platform Support Package](image-3.png)\n\nPSP는 특정 플랫폼(하드웨어 + OS 조합)에 종속적인 기능들을 제공하는 계층이다. OSAL보다 한 단계 더 하드웨어에 가깝다고 볼 수 있다.\n\n그러나 PSP에서도 OSAL이 추상화한 API를 사용하기 때문에, 앞쪽 검은 바탕의 `Core Flight Software Framework Architectural Layers` 이미지보다 흰 바탕의 이미지가 조금 더 정확하다. \n\n**플랫폼이란?**\n\nPSP에서 말하는 '플랫폼'은 하드웨어 아키텍처와 OS의 조합이다. \n\n- `pc-linux`: x86 프로세서 + Linux OS\n- `pc-rtems`: x86 프로세서 + RTEMS OS\n- `bbb-rtems`: ARM BeagleBoneBlack 보드 + RTEMS OS\n- `mcp750-vxworks`: PowerPC MCP750 보드 + VxWorks OS\n\n\n같은 OS를 사용하더라도 하드웨어가 다르면 부팅 과정, 메모리 맵, 인터럽트 처리 방식이 각각 다르다. 이런 차이를 PSP에서 추상화한다.\n\n플랫폼은 **BSP(Board Support Package)** 라는 개념과도 밀접한 관련이 있다.\n\n![출처: https://digitalgateamg.com/services/bsp-development-services/](image-4.png)\n\n세상에는 아두이노와 라즈베리파이부터 시작해 산업용 및 커스텀 보드까지, 다양한 보드가 존재한다. 각 RTOS는 이러한 다양한 하드웨어를 최대한 많이 지원하는데, 이때 OS와 보드를 연결해주는 일종의 미들웨어가 바로 BSP, 번역하면 보드별 지원 패키지이다. \n\ncFS의 PSP는 그 BSP를 사용해서 cFS에 필요한 플랫폼 서비스를 제공하는 것이다. 다시 말해 PSP는 BSP 위에서 동작하는 것!\n\n- **pc-linux (x86 + Linux)**\n```c\n/* pc-linux/src/cfe_psp_start.c */\n// 로컬 디렉토리를 /cf로 매핑\nStatus = OS_FileSysAddFixedMap(&fs_id, \"./cf\", \"/cf\");\n```\n\n- **pc-rtems (x86 + RTEMS)**\n```c\n/* pc-rtems/src/cfe_psp_start.c */\n// 임베디드 시스템의 EEPROM을 /cf로 매핑\nStatus = OS_FileSysAddFixedMap(&fs_id, \"/mnt/eeprom\", \"/cf\");\n```\n\n- **bbb-rtems (ARM BeagleBone Black + RTEMS)**\n```c\n/* bbb-rtems/src/cfe_psp_start.c */\n// 비휘발성 메모리 영역을 /cf로 매핑\nStatus = OS_FileSysAddFixedMap(&fs_id, \"/nonvol\", \"/cf\");\n```\n\nPSP는 각 플랫폼의 특성에 맞게 구현된다. 위 코드는 cFS의 `/cf` 디렉토리를 실제 파일시스템에 매핑하는 부분이다.\n\n동일한 함수(`OS_FileSysAddFixedMap`)를 호출하지만, 매핑되는 실제 경로는 플랫폼의 하드웨어 특성을 따른다. Linux는 개발 환경이므로 현재 디렉토리의 `./cf`를 사용하고, RTEMS 기반 임베디드 시스템들은 각각 EEPROM이나 비휘발성 메모리 같은 실제 하드웨어 메모리를 사용한다.\n\n### cFE (Core Flight Executive)\n\n![Core Flight Executive](image-5.png)\n\ncFE는 cFS의 핵심 계층으로, OSAL과 PSP 위에서 동작하며 애플리케이션들이 공통적으로 필요로 하는 서비스들을 제공한다. cFE가 제공하는 주요 서비스는 다음과 같다.\n\n- **Executive Services (ES)**: 애플리케이션 생명주기를 관리한다. 앱 시작, 중지, 재시작, 예외 처리, 성능 모니터링 등을 담당한다.\n\n- **Software Bus (SB)**: 애플리케이션 간 메시지 기반 통신을 제공한다. Publish-Subscribe 패턴으로 동작하며, 애플리케이션들은 직접 연결되지 않고 소프트웨어 버스를 통해 메시지를 주고받는다.\n\n- **Event Services (EVS)**: 시스템 이벤트와 로그 메시지를 관리한다. 이벤트를 필터링하고, 지상국으로 전송하거나 로그 파일에 기록한다.\n\n- **Time Services (TIME)**: 시스템 시간과 우주선 시간을 관리한다. 타임스탬프 제공, 시간 동기화 등을 담당한다.\n\n- **Table Services (TBL)**: 런타임에 변경 가능한 설정 데이터(테이블)를 관리한다. 지상에서 업로드한 설정을 검증하고 적용하는 메커니즘을 제공한다.\n\n애플리케이션 개발자는 하드웨어나 OS를 전혀 신경쓰지 않고 cFE API만 사용하여 손쉽게 cFS 앱을 구현할 수 있다. \n\n예를 들어 다른 앱에 메시지 전송 시에는 `CFE_SB_TransmitMsg()`, 이벤트 로그 출력 시에는 `CFE_EVS_SendEvent()`, 테이블 로드 시에는 `CFE_TBL_Load()` 등의 API를 사용하면 되며 어떤 플랫폼에서든 동일하게 동작한다.\n\n### cFS 애플리케이션 계층\n\n![Applications and Tools](image-6.png)\n\ncFS의 최상위 계층에는 실제 미션을 수행하는 애플리케이션들이 위치한다. 애플리케이션 및 툴은 크게 세 가지로 분류되는데, 대부분의 우주 미션에서 공통적으로 필요한 범용 앱들, 각 미션에 특화된 커스텀 앱들, 개발 및 테스트를 위한 도구들로 구분된다.\n\n앱들의 종류는 위 이미지에서 색상으로 구별할 수 있다.\n\n## 🎁 cFS 프레임워크의 장점\n\n![Why do we have to use cFS?](image-7.png)\n\ncFS는 검증된 품질과 신뢰성, 개발 비용 및 시간 절감, 활발한 커뮤니티 등 여러 이점을 갖고 있다. NASA에서 사용되고 있는 만큼 장기적으로 높은 품질이 유지되고, 계속해서 업데이트되고 있으며, 새로운 미션을 시작할 때 뼈대 프로그램을 개발하는 데 시간을 쓰지 않아도 된다.\n\n그러나 내가 생각하는 가장 큰 장점은 각 계층의 추상화를 통한 **이식성**에 있다. 툴체인만 바꿔서 재컴파일하면 그 어떤 보드와 운영체제에서도 멀쩡히 실행된다는 뜻인데, 이게 진가를 발휘하는 건 어떤 때냐! **바로 리눅스에서 개발 후 컴파일만 다시 하면 그대로 실제 보드에 올릴 수 있다**는 것이다.\n\n사용하는 보드에 맞는 PSP만 준비되어 있다면 애플리케이션을 개발 단계에서 하드웨어가 구비되어 있을 필요가 전혀 없다. 물리적 상황에 구애받지 않고 개발이 가능하다는 점은 임베디드 개발에 있어 혁명과도 같다고 생각한다.\n\n## ✨ 마치며\n\n분명 머리로는 어느 정도 이해하고 있었는데, 아는 것을 글로 정리해 옮기는 건 언제나 어려운 일인 것 같다. 설명이 부족했던 부분은 없었길 ㅎㅎ 🙏🏻\n\n시각 자료는 유튜브 영상에서 사용하는 것와 같은 자료이다. 개인적으로 영상 설명은 <*How NASA Recycles Software - What is cFS?*> 가, 자료는 <*cFS Overview Presentation*> 이 잘 구성되어 있는 것 같다고 생각해서 두 자료를 같이 사용했다.\n\n아래 링크에서 PDF 파일을 바로 확인할 수 있다. \n\n~[How NASA Recycles Software - What is cFS?]()~: PDF 링크가 삭제되었습니다. 요청하시면 송부해 드리겠습니다.\n\n[cFS Overview Presentation](https://directory.elisa.tech/workshops/2024-12-Maryland/cFS-Overview-Richard-Landau-NASA.pdf)"},{"excerpt":"🚀 들어가며 지금까지 플러그인 매니저, 파일 트리, 버퍼라인, 각종 옵션, 코드 진단을 위한 언어 서버(LSP) 등을 살펴보았다. 직접 configuration이 가능한 만큼 Neovim의 각종 설정과 플러그인은 무궁무진하다. 내 개인 설정은 Neovim을 켜면 가장 먼저 대시보드가 뜨게 하는 플러그인과 터미널 플러그인을 구성하는 것으로 마무리하지만, N…","fields":{"slug":"/neovim-greeting-terminal/"},"frontmatter":{"date":"December 01, 2025","title":"[Neovim] Neovim 마무리: 시작 화면과 터미널 토글","tags":["neovim","ide"]},"rawMarkdownBody":"\n## 🚀 들어가며\n\n지금까지 플러그인 매니저, 파일 트리, 버퍼라인, 각종 옵션, 코드 진단을 위한 언어 서버(LSP) 등을 살펴보았다.\n\n직접 configuration이 가능한 만큼 Neovim의 각종 설정과 플러그인은 무궁무진하다. 내 개인 설정은 Neovim을 켜면 가장 먼저 대시보드가 뜨게 하는 플러그인과 터미널 플러그인을 구성하는 것으로 마무리하지만, Neovim을 200% 활용하기 위해서는 이 외에도 자신에게 맞는 설정을 찾아다니는 것이 중요하다.\n\n**참고**: Neovim에서 필수로 여겨지지만 나에게 필요하지 않아서 추가하지 않은 플러그인에는 `treesitter`, `autocompletion`, `autoformatting`이 있다. 나는 주로 C 코드 분석만 하기 때문에 건너뛰었지만 이 기능이 필요하다면 유튜브 영상을 참고해 구성하는 것을 권장한다.\n\n## 🌅 대시보드 플러그인: `alpha-nvim`\n\nBarbar 플러그인을 설정하면 Neovim을 켤 때 자동으로 빈 버퍼가 나타난다. 솔직히 미관상 별로이다.😑 다른 사람들도 그렇게 생각했는지 Neovim을 켜면 대시보드가 나타나도록 하는 플러그인을 여러 가지 만들어 놓았다! 🤩\n\n[`alpha-nvim` Github(클릭)](https://github.com/goolord/alpha-nvim)에서 설정을 복사해 `plugins` 폴더 내 새로운 파일을 만들어 추가한다.\n\n현재 모든 아이콘을 `nvim-web-devicons` 라이브러리에서 가져다 쓰고 있으므로 동일하게 맞춰준다.\n\n```lua\n-- [[ lua/plugins/alpha-nvim.lua ]]\n\nreturn {\n  \"goolord/alpha-nvim\",\n  -- dependencies = { 'nvim-mini/mini.icons' },\n  dependencies = { 'nvim-tree/nvim-web-devicons' },\n  config = function()\n    local startify = require(\"alpha.themes.startify\")\n    -- available: devicons, mini, default is mini\n    -- if provider not loaded and enabled is true, it will try to use another provider\n    startify.file_icons.provider = \"devicons\"\n    require(\"alpha\").setup(\n      startify.config\n    )\n  end,\n}\n```\n\n### Startify 테마\n\n기본 시작 설정은 startify 테마로, 대시보드에 최근 파일 목록이 나타난다.\n\n대괄호 안의 숫자를 누르면 해당 파일 버퍼가 바로 켜져서 굉장히 유용하다. 나는 현재 이 설정을 사용하고 있다.\n\n![Startify 대시보드 화면](image-5.png)\n\n### Dashboard-nvim 테마\n\nDashboard-nvim 테마는 startify와 달리 적용된 아이콘 라이브러리를 자동 감지하기 때문에 명시적으로 아이콘을 설정하지 않아도 된다. config 함수 내부를 다음과 같이 수정한다.\n\n```lua\n-- [[ lua/plugins/alpha-nvim.lua ]]\n\nreturn {\n  \"goolord/alpha-nvim\",\n  -- dependencies = { 'nvim-mini/mini.icons' },\n  dependencies = { 'nvim-tree/nvim-web-devicons' },\n  config = function()\n    require(\"alpha\").setup(require(\"alpha.themes.dashboard\").config)\n  end,\n}   \n```\n테마를 적용하면 다음과 같이 간략한 메뉴가 나타난다.\n\n![Dashboard-nvim 대시보드 화면](image.png)\n\n### 다양한 커스텀 테마 적용\n\n기본 아스키 아트 외에 유저들이 다양한 커스텀 설정을 [`alpha-nvim` Discussion #16 (클릭)](https://github.com/goolord/alpha-nvim/discussions/16)에서 공유하고 있다.\n\n예쁜 아트들이 많으니 둘러보는 것을 권장한다. 나는 개인적으로 진격의 거인 자유의 날개 아트가 예뻐서 눈여겨보는 중이다. 🙈\n\n## 🪄 파일 트리 자동 토글\n\n일반적으로 VSCode는 파일 트리를 한 번 켜면 이후에 에디터를 켤 때도 파일 트리가 계속 나타난다. Neovim에서도 마찬가지로 파일 트리가 무조건 나타나게 하고 싶었다.\n\nNeo-tree 플러그인에서 자동 토글을 켜 봤는데, 대시보드를 가리는 형태로 나타나서 대시보드 플러그인에서 파일 트리를 토글하는 방식으로 변경했다.\n\n```lua\n-- [[ lua/plugins/alpha-nvim.lua ]]\n\n-- Line 13\n-- alpha 대시보드가 켜질 때(파일 타입이 'alpha'가 될 때) neo-tree도 같이 열기\nvim.api.nvim_create_autocmd(\"FileType\", {\n  pattern = \"alpha\", -- alpha 대시보드의 파일 타입\n  group = vim.api.nvim_create_augroup(\"alpha_open_neotree\", { clear = true }),\n  callback = function()\n    -- 'silent'는 Neotree를 연다는 메시지가 뜨지 않게 합니다.\n    vim.cmd(\"silent Neotree\")\n  end,\n})\n```\n\n## 📦 터미널 플러그인 설치\n\n개발을 하다 보면 터미널로 Git 작업이나 빌드 및 컴파일 작업을 해야 할 때가 많다. 터미널을 써야 할 때마다 탭을 바꾸거나 에디터를 꺼야 하는 게 번거로워서 터미널 플러그인을 설치했다.\n\n터미널 플러그인에도 종류가 몇 가지 있는데, 나는 이 중 [`toggleterm.nvim` (클릭)](https://github.com/akinsho/toggleterm.nvim)으로 설치했다.\n\n### `Lazy.nvim`으로 설치하기\n\n`toggleterm.nvim`의 README에 다음과 같이 플러그인 설치 방법이 소개되어 있다.\n\n```lua\n{\n  -- amongst your other plugins\n  {'akinsho/toggleterm.nvim', version = \"*\", config = true}\n  -- or\n  {'akinsho/toggleterm.nvim', version = \"*\", opts = {--[[ things you want to change go here]]}}\n}\n```\n\n기본 토글 단축키는 `Ctrl + \\`인데, 나는 단축키를 `Ctrl + t`로 변경할 예정이기 때문에 두 번째 configuration으로 구성했다.\n\n```lua\n-- [[ lua/plugins/toggleterm.lua ]]\n\nreturn {\n  'akinsho/toggleterm.nvim',\n  version = \"*\",\n  opts = {\n    open_mapping = '<C-T>',\n    terminal_mappings = true -- 터미널 내부에서도 같은 단축키로 토글\n  }\n}\n```\n\n### 터미널 위치 변경하기\n\n나는 터미널을 윈도우의 가장 아래에 배치하는 기본 설정을 따르고 있는데, `float` 설정으로 사용하는 사람들도 굉장히 많다. 다음은 터미널이 hover 되게 하는 코드이다.\n\n내 코드에는 float 설정이 적용되어 있지 않아 실제로 적용하려면 좀 더 검색이 필요하다.\n\n**1. 기본 설정에서 float로 지정**\n\n```lua\nrequire(\"toggleterm\").setup{\n  direction = 'float',\n  float_opts = {\n    border = 'double',  -- 'single', 'double', 'shadow', 'curved' 등\n    width = 120,\n    height = 30,\n    winblend = 3,\n  }\n}\n```\n\n**2. 명령어 실행할 때 direction 지정**\n\n    vim:ToggleTerm direction=float\n\n**3. 특정 터미널만 float로 만들기**\n\n```lua\nlocal Terminal = require('toggleterm.terminal').Terminal\nlocal float_term = Terminal:new({\n  direction = \"float\",\n  float_opts = {\n    border = \"double\",\n  },\n  on_open = function(term)\n    vim.cmd(\"startinsert!\")\n  end,\n})\n\nfunction _float_term_toggle()\n  float_term:toggle()\nend\n\nvim.keymap.set(\"n\", \"<leader>ft\", \"<cmd>lua _float_term_toggle()<CR>\", {noremap = true, silent = true})\n```\n\n## ✨ 마치며\n\n내가 현재 사용하는 모든 Neovim configuration에 대한 포스팅이 마무리되었다.\n\n보통 여기에 LazyGit 등 Git configuration을 같이 넣는 경우가 많은데, 난 git은 그냥 터미널로 관리하는게 편해서 구성하지 않았다. 원본 영상에는 포함되어 있기 때문에 참고하면 좋을 것 같다.\n\n에디터를 구성하며 가장 많이 한 생각은... VSCode가 얼마나 대단한 에디터인가에 대한 고찰... 이걸 대체 어떻게 한 거지 라는 놀라움...\n\n특히 스크롤바 플러그인을 찾아다닐 때 많이 느꼈다. 😂 언젠가는 VSCode같은 스크롤바를 적용시켜 내야지! 점점 성장하는 내가 되었으면 좋겠다."},{"excerpt":"🚀 들어가며 IDE를 사용하는 가장 큰 이유 중 하나는 에러나 경고를 컴파일 전에 탐지해 코딩을 용이하게 만들어 주는 것이다. 이를 위한 한 방법이 LSP(Language Server Protocol)인데, IDE상에서 다양한 프로그래밍 언어들에 대한 개발 편의 기능을 보편적으로 구현하기 위해 탄생한 프로토콜이다. Neovim에도 LSP을 구성하면 코딩이…","fields":{"slug":"/neovim-telescope-lsp/"},"frontmatter":{"date":"November 24, 2025","title":"[Neovim] Dignostics를 위한 Telescope 및 LSP 설정","tags":["neovim","ide"]},"rawMarkdownBody":"\n## 🚀 들어가며\n\nIDE를 사용하는 가장 큰 이유 중 하나는 에러나 경고를 컴파일 전에 탐지해 코딩을 용이하게 만들어 주는 것이다. 이를 위한 한 방법이 LSP(Language Server Protocol)인데, IDE상에서 다양한 프로그래밍 언어들에 대한 개발 편의 기능을 보편적으로 구현하기 위해 탄생한 프로토콜이다.\n\nNeovim에도 LSP을 구성하면 코딩이 훨씬 편리하다. 다만 LSP는 초보자가 직접 구성하기 다소 까다로워서, 이번에는 `kickstart.nvim`에서 설정을 빌려와 구성해 보려 한다.\n\n## 🔭 Telescope Fuzzy Finder\n\nLSP에 앞서 Telescope Fuzzy Finder를 먼저 설치해야 한다. LSP 설정에 Telescope 플러그인 설정이 포함되어 있기 때문인데..\n\n그렇다면 Fuzzy Finder란 무엇이냐! 😎 Fuzzy Finder는 리스트에서 항목을 검색할 때 정확한 이름을 몰라도 대략적인 패턴만으로 빠르게 찾아주는 대화형 검색 도구이다. \n\n예를 들어 `MyProjectController.java`라는 파일을 찾을 때 `mpc`나 `projcont` 같은 축약된 패턴만 입력해도 fuzzy matching 알고리즘이 관련 파일을 찾아준다. 터미널에서는 `fzf`가 가장 유명한 fuzzy finder이고, Neovim에서는 Telescope가 그 역할을 한다.\n\n### `kickstart.nvim`에서 Telescope 설정 복사\n\nKickstart의 `init.lua`파일의 라인 360번 전후로 Telescope configuration이 있다. `Fuzzy Finder (files, lsp, etc)` 부터 시작해 해당 중괄호 모두를 복사하면 된다.\n\n```lua\n-- [[ kickstart.nvim/init.lua ]]\n\n{ -- Fuzzy Finder (files, lsp, etc)\n  'nvim-telescope/telescope.nvim',\n  -- [[ More configs.. ]]\n  config = function()\n    require('telescope').setup {\n      -- You can put your default mappings / updates / etc. in here\n      --  All the info you're looking for is in `:help telescope.setup()`\n      --\n      -- defaults = {\n      --   mappings = {\n      --     i = { ['<c-enter>'] = 'to_fuzzy_refine' },\n      --   },\n      -- },\n      -- pickers = {}\n      extensions = {\n        ['ui-select'] = {\n          require('telescope.themes').get_dropdown(),\n        },\n      },\n    }\n    -- [[ More configs.. ]]\n  end,\n},\n```\n\n복사한 후에는 새로운 Lua 파일을 생성해 추가한다.\n\n```lua\n-- [[ lua/plugins/telescope.lua ]]\n\nreturn { -- Fuzzy Finder (files, lsp, etc)\n  'nvim-telescope/telescope.nvim',\n  -- 이후 설정들\n}\n```\n\n## 🔦 Telescope 커스텀 설정\n\n### 커스텀 키 매핑\n\nKickstart의 기본 키 매핑은 다음과 같이 되어 있다.\n\n```lua\nvim.keymap.set('n', '<leader>sh', builtin.help_tags, { desc = '[S]earch [H]elp' })\nvim.keymap.set('n', '<leader>sk', builtin.keymaps, { desc = '[S]earch [K]eymaps' })\nvim.keymap.set('n', '<leader>sf', builtin.find_files, { desc = '[S]earch [F]iles' })\nvim.keymap.set('n', '<leader>ss', builtin.builtin, { desc = '[S]earch [S]elect Telescope' })\nvim.keymap.set('n', '<leader>sw', builtin.grep_string, { desc = '[S]earch current [W]ord' })\nvim.keymap.set('n', '<leader>sg', builtin.live_grep, { desc = '[S]earch by [G]rep' })\nvim.keymap.set('n', '<leader>sd', builtin.diagnostics, { desc = '[S]earch [D]iagnostics' })\nvim.keymap.set('n', '<leader>sr', builtin.resume, { desc = '[S]earch [R]esume' })\nvim.keymap.set('n', '<leader>s.', builtin.oldfiles, { desc = '[S]earch Recent Files (\".\" for repeat)' })\nvim.keymap.set('n', '<leader><leader>', builtin.buffers, { desc = '[ ] Find existing buffers' })\n```\n\n개인적으로 리더 키를 사용하는 걸 선호하지 않아서, 리더 키 없이 키보드만 눌러도 되도록 바꿔 사용할 것이다.\n\n```lua\nvim.keymap.set('n', 'fw', builtin.grep_string, { desc = ':Telescope grep_string' })\nvim.keymap.set('n', 'fd', builtin.diagnostics, { desc = ':Telescope diagnostics' })\nvim.keymap.set('n', 'ff', builtin.find_files,  { desc = ':Telescope find_files' })\nvim.keymap.set('n', 'fg', builtin.live_grep,   { desc = ':Telescope live_grep' })\nvim.keymap.set('n', 'fh', builtin.help_tags,   { desc = ':Telescope help_tags' })\nvim.keymap.set('n', 'fk', builtin.keymaps,     { desc = ':Telescope keymaps' })\nvim.keymap.set('n', 'fb', builtin.buffers,     { desc = ':Telescope buffers' })\n```\n\n### 검색에서 제외할 파일 설정하기\n\n`find_files`, `live_grep`을 할 때 `node_modules`, `.git`, `.venv` 파일들은 검색하지 않고, 다른 숨겨진 파일들은 검색되도록 설정한다.\n\n```lua\n-- [[ lua/plugins/telescope.lua ]]\n\n-- Line 56\npickers = {\n  find_files = {\n    file_ignore_patterns = { 'node_modules', '.git', '.venv' },\n    hidden = true,\n  },\n},\n\n-- Line 65\nlive_grep = {\n  file_ignore_patterns = { 'node_modules', '.git', '.venv' },\n  additional_args = function(_)\n    return { '--hidden' }\n  end,\n},\n```\n\n## 💨 Telescope 단축키로 파일 및 심볼 검색하기\n\n### `find_files` 키맵\n\n단축키에 지정한 대로 노멀 모드에서 `ff`를 입력하면 telescope의 파일 검색 기능이 실행된다. \n\n![find_files](image.png)\n\n![find_files: 검색어 입력](image-1.png)\n\n### `live_grep` 키맵\n\n노멀 모드에서 `fg`를 입력하면 단어를 검색할 수 있다.\n\n![live_grep](image-2.png)\n\n### `grep_string` 키맵\n\n검색할 단어 위에 커서를 배치하고 `fw` 단축키를 입력하면 해당 단어를 검색한다. 단축어는 `find_word`의 약자로 정하였다.\n\n![검색할 단어 위에 커서를 놓은 모습](image-3.png)\n\n![`fw`로 검색](image-4.png)\n\n## 🤖 LSP: Language Server Protocol\n\n### `kickstart.nvim`에서 LSP 설정 복사\n\n`kickstart.nvim`의 `init.lua`파일의 라인 480번 전후로 LSP configuration이 있다. Main LSP Configuration 부터 시작해 해당 중괄호 모두를 복사하면 된다. 약 250줄 이상의 분량이다.\n\n```lua\n-- [[ kickstart.nvim/init.lua ]]\n\n{\n  -- Main LSP Configuration\n  'neovim/nvim-lspconfig',\n  dependencies = {\n    -- [[ Dependency configs.. ]] \n  },\n  config = function()\n    -- [[ More configs.. ]]\n\n    local servers = {\n      -- [[ Server configs.. ]]\n    }\n\n    -- Ensure the servers and tools above are installed\n    local ensure_installed = vim.tbl_keys(servers or {})\n    -- [[ Mason configs.. ]]\n  end,\n},\n```\n\n복사한 후에는 새로운 Lua 파일을 생성해 추가한다.\n\n```lua\n-- [[ lua/plugins/lsp.lua ]]\n\nreturn {\n  -- Main LSP Configuration\n  'neovim/nvim-lspconfig',\n\n  -- 이후 설정들\n}\n```\n\n### `undefined global vim` 에러\n\n플러그인을 저장하고 다시 실행하면 Lua 파일들에 `undefined global vim` 이라는 경고가 굉장히 많이 뜨게 된다.\n\n유튜브 영상에서 소개하는 해결 방법은 Neovim 0.10에만 해당하고 0.11에서는 작동하지 않는다. [Github PR(클릭)](https://github.com/nvim-lua/kickstart.nvim/pull/1475/commits/a590ab6c8812ade054cf0f444ee53c1b0daa98a3)을 참고하여 코드 마지막을 다음과 같이 수정하면 경고가 사라진다.\n\n```lua\n-- [[ lua/plugins/lsp.lua ]]\n\n-- Line 211\nlua_ls = {\n  settings = {\n    Lua = {\n      completion = {\n        callSnippet = 'Replace',\n      },\n      runtime = { version = 'LuaJIT' },\n      workspace = {\n        checkThirdParty = false,\n        library = {\n          vim.env.VIMRUNTIME,\n        }\n      },\n      diagnostics = {\n        globals = { 'vim' },\n        disable = { 'missing-fields' },\n      },\n      format = {\n        enable = false,\n      },\n    },\n  },\n},\n\n-- Line 247\nlocal ensure_installed = vim.tbl_keys(servers or {})\nvim.list_extend(ensure_installed, {\n  'stylua', -- Used to format Lua code\n})\nrequire('mason-tool-installer').setup { ensure_installed = ensure_installed }\n-- Handle LSP setups\n-- See :help vim.lsp.enable\nfor server, config in pairs(servers) do \n  vim.lsp.config(server, config)\n  vim.lsp.enable(server)\nend\n```\n\n## 📖 LSP 기본 설정 소개\n\nKickstart의 LSP 설정에는 LSP를 쉽게 설치하고 관리하기 위한 플러그인들이 포함되어 있다.\n\n### 1. nvim-lspconfig (메인 플러그인)\n\n```lua\n'neovim/nvim-lspconfig'\n```\n\n- Neovim의 내장 LSP 클라이언트 설정을 쉽게 해주는 플러그인\n- 각 Language Server(`clangd`, `pyright` 등)를 Neovim에 연결하는 설정 제공\n- 하지만 **LSP 서버 자체를 설치해주지는 않는다.**\n\n### 2. mason.nvim\n\n```lua\n{ 'mason-org/mason.nvim', opts = {} }\n```\n\n- **LSP 서버, Linter, Formatter 등을 Neovim 안에서 설치/관리**하는 패키지 매니저\n- `:Mason` 명령어로 GUI를 열어서 필요한 도구들을 클릭만으로 설치 가능\n- 시스템에 직접 `sudo apt install clangd` 등의 명령어를 입력해서 서버를 설치할 필요가 없다! 😙\n- `opts = {}`는 `require('mason').setup({})`와 동일 (기본 설정으로 초기화)\n\n### 3. mason-lspconfig.nvim\n\n```lua\n'mason-org/mason-lspconfig.nvim'\n```\n\n- **Mason과 lspconfig를 연결**하는 브릿지 역할\n- Mason으로 설치한 LSP 서버를 lspconfig가 자동으로 인식하게 해 준다.\n- 서버 이름 매핑 (예: Mason의 `typescript-language-server` → lspconfig의 `tsserver`)\n- 자동 설치 기능 제공\n\n### 4. mason-tool-installer.nvim\n\n```lua\n'WhoIsSethDaniel/mason-tool-installer.nvim'\n```\n\n- **LSP 서버 외의 추가 도구들을 자동 설치**\n- Linter, Formatter, Debugger 등\n- 설정 파일에 필요한 도구 목록을 적어두면 Neovim 실행 시 자동으로 설치\n\n### 핵심 변화\n\n예전에는 시스템에 `sudo apt install clangd`등의 명령어를 입력해서 직접 설치해야 했다. 그러나 이제는 Mason으로 Neovim 안에서 `:Mason` 커맨드를 실행하고 `clangd`와 같이 검색하면 설치할 수 있고, 이것도 LSP 구성 함수 내에서 자동화되었다.\n\n## 🎛️ LSP 커스텀 설정하기\n\n### 필요한 language server 추가 설치\n\n위 설명처럼, 원하는 LSP 서버에 대해 코드 한 줄만 추가하면 재시작 시 자동으로 설치된다.\n\n나는 C를 자주 사용하고 개발 환경 설정을 위해 도커 환경을 세팅할 일이 많아 이 두 언어 서버를 우선 설치하였다.\n\n```lua\n-- Line 198\nclangd = {},\ndockerls = {},\n```\n\n### 키맵 설정하기\n\n인텔리제이에서 `Ctrl`을 누른 상태로 변수를 클릭하면 변수의 정의로 이동할 수 있는 것처럼 LSP도 비슷한 기능을 제공한다. 다음은 이를 위한 단축키이다.\n\nTelescope 단축키를 설정했던 것과 마찬가지로 리더 키를 사용하지 않도록 구성했다.\n\n```lua\n-- User-configured keymaps, this is not from kickstart\nlocal builtin = require('telescope.builtin')\n\n-- Most Language Servers support renaming across files, etc.\nvim.keymap.set('n', 'gn', vim.lsp.buf.rename, { desc = 'Rename the variable under your cursor' })\n\n-- Find references for the word under your cursor.\nvim.keymap.set('n', 'gr', builtin.lsp_references, { desc = '[G]oto [R]eferences' })\n\n-- Useful when your language has ways of declaring types without an actual implementation.\nvim.keymap.set('n', 'gi', builtin.lsp_implementations, { desc = '[G]oto [I]mplementation' })\n\n-- This is where a variable was first declared, or where a function is defined, etc.\n-- To jump back, press <C-t>.\nvim.keymap.set('n', 'gd', builtin.lsp_definitions, { desc = '[G]oto [D]efinition' })\n```\n\n## ✨ 마치며\n\n단순 preference 설정이 아니라 실제 기능을 구성해야 하다 보니 시간이 오래 걸렸다. 사실 실제 개발보다 C 코드를 분석할 일이 많아서 라이브러리를 찾지 못한다는 에러가 너무 많아 그동안 LSP를 끄고 지냈는데, 블로그를 포스팅하며 설정을 다시 들여다볼 수 있었다.\n\n보통 여기에 LazyGit 등 Git configuration을 같이 넣는 경우가 많은데, 난 git은 그냥 터미널로 관리하는게 편해서 구성하지 않았다. 원본 영상에는 포함되어 있기 때문에 참고하면 좋을 것 같다."},{"excerpt":"🚀 들어가며 Vim을 처음 사용해본 사람이라면 모두 한번쯤은, 습관적으로 로 취소를 하려다 프로세스가 일시정지되어 Vim이 꺼져버려 당황한 기억이 있을 것이다.🤦 나만 해도 교수님이 당부에 당부를 거듭하셨음에도 시험을 보다 습관적으로 를 누르고... 손을 달달 떨며 기억을 더듬어 로 복구한 경험이 있다 😵 이렇게 윈도우와 리눅스 및 Vim의 단축키가 다른…","fields":{"slug":"/neovim-keymap/"},"frontmatter":{"date":"November 11, 2025","title":"[Neovim] Custom Keymap 설정하기","tags":["neovim","ide"]},"rawMarkdownBody":"\n## 🚀 들어가며\n\nVim을 처음 사용해본 사람이라면 모두 한번쯤은, 습관적으로 `Ctrl+Z`로 취소를 하려다 프로세스가 일시정지되어 Vim이 꺼져버려 당황한 기억이 있을 것이다.🤦 나만 해도 교수님이 당부에 당부를 거듭하셨음에도 시험을 보다 습관적으로 `Ctrl+Z`를 누르고... 손을 달달 떨며 기억을 더듬어 `fg`로 복구한 경험이 있다 😵\n\n이렇게 윈도우와 리눅스 및 Vim의 단축키가 다른 게 정말 불편한 요소 중 하나인데, Neovim에서 키 매핑을 통해 이 간극을 줄일 수 있다.\n\n우리의 목표는 항상! VSCode와 가장 유사한 개발 환경을 만드는 것이므로 최대한 윈도우 및 VSCode와 이질감이 없게 커스텀을 해 보자.\n\n## 🎯 파일 생성 및 적용\n\n먼저 `lua/core/keymaps.lua` 파일을 생성한다. 이전 포스트처럼 파일 트리에서 `a`키로 생성하거나 터미널에서 `touch` 명령어를 사용하면 된다.\n\n그 후 `init.lua` 파일에 생성한 `keymaps.lua` 파일을 import한다.\n\n```lua\nrequire 'core.keymaps'\n```\n\n## ⌨️ 키맵 옵션 설정\n\n먼저 키맵 설정에 자주 사용할 옵션들을 변수로 정의해두면 코드가 훨씬 깔끔해진다.\n\n```lua\nlocal keyset = vim.keymap.set\nlocal remap_opt = { remap = true }\nlocal remap_silent_opt = { remap = true, silent = true }\nlocal noremap_opt = { noremap = true }\nlocal noremap_silent_opt = { noremap = true, silent = true }\n```\n\n- `keyset`: `vim.keymap.set`의 축약형으로 타이핑을 줄여준다.\n- `noremap`: 재귀적 매핑을 방지한다. 키맵이 다른 키맵을 다시 호출하지 않도록 한다.\n- `silent`: 명령어 실행 시 하단에 메시지를 표시하지 않는다.\n- `remap`: 플러그인의 키맵을 재사용할 때 필요하다.\n\n## 👔 Leader 키 설정\n\n```lua\nvim.g.mapleader = ' '\nvim.g.maplocalleader = ' '\n\nkeyset({ 'n', 'v' }, '<Space>', '<Nop>', { silent = true })\n```\n\n**Leader 키**는 복잡한 명령어 조합의 시작점이 되는 키다. 윈도우가 보통 Ctrl키와 글자 키를 조합해 단축어를 지정하는 것처럼, Neovim에서는 리더 키와 다른 일반 키를 조합한다.\n\n보통 `Space`를 많이 사용하는데, 손가락이 닿기 가장 편한 위치라 자주 쓰는 명령어들을 조합하기 좋다. `<Nop>`로 설정한 이유는 Space의 기본 동작(커서 오른쪽 이동)을 비활성화하여 Leader 키로만 사용하기 위함이다.\n\n슬슬 지겨울 수도 있지만 😅 우리는 VSCode를 지향하니까.. 리더 키는 나중을 위해 일단 설정만 해 두었고 실제로 단축어를 설정해 두지는 않았다.\n\n변수 순서는 '모드', '설정할 키맵', '실행할 명령', '옵션' 순이다.\n\n## 🌐 전역 함수\n\n### Neo-tree 토글 함수\n\n```lua\nfunction _G.toggle_neotree()\n  local manager = require(\"neo-tree.sources.manager\")\n  local state = manager.get_state(\"filesystem\")\n\n  if state.winid and vim.api.nvim_win_is_valid(state.winid) then\n    require('neo-tree.command').execute({ action = \"close\" })\n  else\n    require('neo-tree.command').execute({ action = \"focus\", source = \"filesystem\" })\n  end\nend\n```\n\nNeo-tree가 열려있으면 닫고, 닫혀있으면 열도록 하는 토글 함수다. `Ctrl+B`로 VSCode의 사이드바 토글처럼 사용할 수 있다.\n\n## 🕹️ Normal 모드 - 편집 및 파일 관리\n\n### 유용한 Normal 모드 키맵\n\n```lua\nkeyset('n', 'dd',     '\"_dd', noremap_opt)    -- 줄 삭제 (레지스터에 저장 안 함)\nkeyset('n', 'dt',     '<CMD>lua vim.diagnostic.config({virtual_text = not vim.diagnostic.config().virtual_text})<CR>', noremap_opt) -- LSP 진단 메시지 토글\n```\n\n`dd`를 재정의해서 삭제한 내용이 클립보드를 오염시키지 않도록 했다. Vim에서는 삭제도 복사처럼 레지스터에 저장되는데, 이게 은근 불편할 때가 많다.\n\n또한 diagnostic이 너무 많이 표시되어 있으면 코드와 구별되지 않을 때가 있어, 이를 토글할 수 있는 `dt` 단축키를 추가했다.\n\n### VSCode 스타일 단축키\n\n```lua\nkeyset('n', '<C-Q>',  '<CMD>qa<CR>', noremap_opt)        -- 모든 창 닫기\nkeyset('n', '<C-W>',  '<CMD>q<CR>', noremap_opt)         -- 현재 창 닫기\nkeyset('n', '<C-A>',  'gg<S-V>G', noremap_opt)           -- 전체 선택\nkeyset('n', '<C-S>',  '<CMD>noautocmd w<CR>', noremap_opt) -- 저장 (포맷팅 없이)\nkeyset('n', '<C-Z>',  'u', noremap_opt)                  -- Undo\nkeyset('n', '<C-S-Z>', '<C-R>', noremap_opt)             -- Redo\nkeyset('n', '<C-X>',  'dd', noremap_opt)                 -- 현재 줄 잘라내기\nkeyset('n', '<C-C>',  'yy', noremap_opt)                 -- 현재 줄 복사\nkeyset('n', '<C-V>',  'p', noremap_opt)                  -- 붙여넣기\nkeyset('n', '<C-B>',  '<CMD>lua toggle_neotree()<CR>', noremap_opt) -- 파일 트리 토글\nkeyset('n', '<C-_>',  'gcc', remap_opt)                  -- 주석 토글 (Ctrl+/)\n```\n\nVSCode에서 넘어온 사람들이 가장 헷갈려하는 부분을 해결했다. 특히 `Ctrl+S` 저장이 먹히지 않으면 엄청 답답한데, 이제 익숙한 단축키로 편하게 작업할 수 있다.\n\n`<C-_>`가 `Ctrl+/`인 이유는 터미널에서 `Ctrl+/`가 `Ctrl+_`로 인식되기 때문이다. 주석 토글 기능은 Comment 플러그인을 설치하면 활용할 수 있다.\n\n### Leader 키 조합 - Telescope & Git (TBD)\n\n```lua\nkeyset('n', 'ff',     '<CMD>Telescope find_files<CR>', noremap_opt)  -- 파일 검색\nkeyset('n', 'fg',     '<CMD>Telescope live_grep<CR>', noremap_opt)   -- 텍스트 검색\nkeyset('n', 'fh',     '<CMD>Telescope help_tags<CR>', noremap_opt)   -- 도움말 검색\nkeyset('n', 'fb',     '<CMD>Telescope buffers<CR>', noremap_opt)     -- 버퍼 목록\n\nkeyset('n', 'fs',     '<CMD>Gitsigns diffthis<CR>', noremap_opt)     -- Git diff 보기\nkeyset('n', 'fd',     '<CMD>Gitsigns preview_hunk<CR>', noremap_opt) -- Git hunk 미리보기\n```\n\nTelescope는 파일 찾기, 텍스트 검색 등을 할 수 있는 강력한 퍼지 파인더다. `Space + ff`만 누르면 프로젝트 전체에서 파일명으로 검색이 가능하고, `Space + fg`로 내용까지 검색할 수 있다.\n\nGit 관련 기능도 `Space + f` 조합으로 통일해서 외우기 쉽게 만들었다.\n\n(TBD)\n\n## ✍️ Insert 모드 - 편집 중 단축키\n\n```lua\nkeyset('i', '<C-A>',    '<ESC><ESC>gg<S-V>G', noremap_opt)     -- 전체 선택\nkeyset('i', '<C-S>',    '<ESC><ESC>:w<CR>', noremap_opt)       -- 저장\nkeyset('i', '<C-Z>',    '<ESC><ESC>ua', noremap_opt)           -- Undo\nkeyset('i', '<C-S-Z>',  '<ESC><ESC><C-R>a', noremap_opt)       -- Redo\nkeyset('i', '<C-X>',    '<ESC><ESC>dda', noremap_opt)          -- 현재 줄 잘라내기\nkeyset('i', '<C-C>',    '<ESC><ESC>yya', noremap_opt)          -- 현재 줄 복사\nkeyset('i', '<C-V>',    '<ESC><ESC>pi', noremap_opt)           -- 붙여넣기\nkeyset('i', '<C-B>',    '<CMD>lua toggle_neotree()<CR>', noremap_opt) -- 파일 트리\nkeyset('i', '<C-_>',    '<ESC><ESC>gcca', remap_opt)           -- 주석 토글\nkeyset('i', '<S-TAB>',  '<C-V><TAB>', noremap_opt)             -- 실제 탭 문자 입력\n```\n\nInsert 모드에서도 VSCode처럼 저장하고 복사/붙여넣기를 할 수 있다. `<ESC><ESC>`를 두 번 넣은 이유는 가끔 한 번으로는 모드 전환이 제대로 안 될 때가 있어서다.\n\n명령 실행 후 다시 Insert 모드로 돌아가도록 끝에 `a` 또는 `i`를 붙였다.\n\n`Shift+Tab`은 `expandtab` 옵션 때문에 스페이스로 변환되는 것을 방지하고 실제 탭 문자를 입력할 때 사용한다.\n\n## 👁️ Visual 모드 - 블록 선택 및 편집\n\n### 기본 단축키 수정\n\n```lua\nkeyset('v', 'd',      '\"_d', noremap_opt)   -- 삭제 (레지스터 저장 안 함)\nkeyset('v', 'c',      '\"_c', noremap_opt)   -- 변경 (레지스터 저장 안 함)\n```\n\nVisual 모드에서 `d`와 `c`를 재정의해서 불필요한 레지스터 오염을 방지했다. 실제로 잘라내기를 하고 싶을 때는 `Ctrl+X`를 사용하면 된다.\n\n```lua\nkeyset('v', '<BS>',     'd<ESC><ESC>i', noremap_opt)  -- 백스페이스로 삭제 후 Insert\nkeyset('v', '<C-A>',    '<ESC><ESC>gg<S-V>G', noremap_opt)\nkeyset('v', '<C-S>',    '<ESC><ESC>:w<CR>', noremap_opt)\nkeyset('v', '<C-Z>',    '<ESC><ESC>u', noremap_opt)\nkeyset('v', '<C-S-Z>',  '<ESC><ESC><C-R>', noremap_opt)\nkeyset('v', '<C-X>',    'd', noremap_opt)             -- 잘라내기\nkeyset('v', '<C-C>',    'y', noremap_opt)             -- 복사\nkeyset('v', '<C-V>',    'p', noremap_opt)             -- 붙여넣기\nkeyset('v', '<C-B>',    '<CMD>lua toggle_neotree()<CR>', noremap_opt)\nkeyset('v', '<C-_>',    'gc', remap_opt)              -- 주석 토글\n```\n\n`Ctrl` 키 조합은 이전과 유사하다.\n\n## 📑 버퍼 관리 - Function 키 활용\n\n```lua\nkeyset('n', '<F1>',   '<CMD>BufferGoto1<CR>', noremap_silent_opt)\nkeyset('n', '<F2>',   '<CMD>BufferGoto2<CR>', noremap_silent_opt)\nkeyset('n', '<F3>',   '<CMD>BufferGoto3<CR>', noremap_silent_opt)\nkeyset('n', '<F4>',   '<CMD>BufferGoto4<CR>', noremap_silent_opt)\nkeyset('n', '<F5>',   '<CMD>BufferGoto5<CR>', noremap_silent_opt)\nkeyset('n', '<F6>',   '<CMD>BufferGoto6<CR>', noremap_silent_opt)\nkeyset('n', '<F7>',   '<CMD>BufferGoto7<CR>', noremap_silent_opt)\nkeyset('n', '<F8>',   '<CMD>BufferGoto8<CR>', noremap_silent_opt)\nkeyset('n', '<F9>',   '<CMD>BufferGoto9<CR>', noremap_silent_opt)\nkeyset('n', '<F10>',  '<CMD>BufferLast<CR>', noremap_silent_opt)\n```\n\nBarbar 플러그인을 사용하면 상단에 VSCode처럼 탭이 표시된다. Function 키로 버퍼를 번호로 바로 이동할 수 있어서 여러 파일을 오갈 때 엄청 편하다.\n\n`F10`은 마지막 버퍼로 이동하도록 설정했다.\n\n\n\n## 🎓 기타 고급 기능 (TBD)\n\n### Vim 명령어 축약 (Command Abbreviation)\n\n```lua\nvim.cmd([[\n  ca ff Telescope find_files\n  ca fg Telescope live_grep\n  ca fh Telescope help_tags\n  ca fb Telescope buffers\n  ca fk Telescope keymaps\n  ca fc Telescope commands\n  ca fch Telescope command_history\n  ca fsh Telescope search_history\n  ca fhl Telescope highlights\n  ca ww SudaWrite\n]])\n```\n\nCommand 모드(`:` 입력)에서 `ff`만 쳐도 `Telescope find_files`가 자동 완성된다. 긴 명령어를 짧게 줄여서 사용할 수 있어 편리하다.\n\n`ww`는 Suda 플러그인으로 관리자 권한이 필요한 파일을 저장할 때 사용한다.\n\n### 텍스트 검색 및 치환\n\n```lua\nvim.cmd([[\n  vnoremap <F2>  y/<C-R>=escape(@\",'/\\')<CR><CR>N:%s/<C-R>=escape(@\",'/\\')<CR>/<C-R>=escape(@\",'/\\')<CR>/g<Left><Left>\n  vnoremap <F3>  y/<C-R>=escape(@\",'/\\')<CR><CR>N\n]])\n```\n\nVisual 모드에서:\n- `F2`: 선택한 텍스트를 전체 파일에서 일괄 치환할 수 있는 명령어를 자동으로 생성\n- `F3`: 선택한 텍스트를 검색\n\nVSCode의 `Ctrl+H` (찾기 및 바꾸기) 기능과 비슷하게 만든 키맵이다.\n\n### Telescope 커서 모드 검색\n\n```lua\nvim.cmd([[\n  nnoremap <F12> :lua require(\"telescope.builtin\").grep_string({layout_strategy='cursor',layout_config={width=0.5, height=0.45}})<CR>\n  inoremap <F12> <ESC><ESC>:lua require('telescope.builtin').grep_string({layout_strategy='cursor',layout_config={width=0.5, height=0.45}})<CR>\n]])\n```\n\n`F12`를 누르면 커서 아래 단어를 프로젝트 전체에서 검색한다. 함수 정의를 찾거나 변수 사용처를 추적할 때 유용하다.\n\n## ✨ 마치며\n\n지금까지 업로드했던 포스트 중에서 가장 다듬어지지 않았다는 느낌이 다소 든다. 아직 Neovim의 모든 기능들을 익히지 못하기도 했고, 플러그인을 정리해가면서 키맵을 계속 업데이트해야하기 때문인 것 같다.\n\n특히 아직 포스팅하지 않은 LSP와 Telescope 설정이 완료되지 않아서 완성된 키맵 파일을 내놓기는 조금 무리가 있다. 포스팅을 이어가면서 나만의 설정을 계속 정리하고, 키맵 포스팅도 수정해 나가야겠다."},{"excerpt":"🚀 들어가며 지금까지 올렸던 캡처 화면을 보면, 코드 화면 왼쪽에 라인 넘버가 표시되는 걸 볼 수 있다. 그런데 조금 이상한 게 있다는 걸 눈치챘다면 당신은 똑똑이🤭 커서가 있는 라인만 실제 라인 넘버가 표시되고, 그 외에는 아래위로 몇 줄을 가야 하는지가 표시된다. Neovim을 쓰려고 한다면 웬만한 Vim 기능은 알고 있겠지만, 이렇게 상대적 라인 넘…","fields":{"slug":"/neovim-options/"},"frontmatter":{"date":"November 10, 2025","title":"[Neovim] Vim 사용자 옵션 설정","tags":["neovim","ide"]},"rawMarkdownBody":"\n## 🚀 들어가며\n\n지금까지 올렸던 캡처 화면을 보면, 코드 화면 왼쪽에 라인 넘버가 표시되는 걸 볼 수 있다.\n\n그런데 조금 이상한 게 있다는 걸 눈치챘다면 당신은 똑똑이🤭 커서가 있는 라인만 실제 라인 넘버가 표시되고, 그 외에는 아래위로 몇 줄을 가야 하는지가 표시된다.\n\nNeovim을 쓰려고 한다면 웬만한 Vim 기능은 알고 있겠지만, 이렇게 상대적 라인 넘버가 표시되면 `10j`(위로 10줄 이동), `5k`(아래로 5줄 이동), `3dd`(3줄 오려내기)처럼 라인 수를 지정하는 명령어를 입력하기가 한결 편하다.\n\n이번 포스트에서는 이런 라인 넘버 설정처럼 유용한 Neovim 설정을 다루려고 한다.\n\n## 🎯 파일 생성 및 적용\n\n먼저 `lua/core/options.lua` 파일을 생성해 저장한다. 파일 트리에서 `a`키로 생성 가능하고, 터미널에서 `touch` 명령어로 생성할 수도 있다.\n\n![lua/core/options.lua](image-3.png)\n\n그 후 `init.lua` 파일에 생성한 `options.lua` 파일을 import한다.\n\n```lua\nrequire 'core.options'\n```\n\n![init.lua](image-4.png)\n\n## 🎨 UI & DISPLAY - 화면 표시 설정\n\n![UI & DISPLAY 적용 화면](image-1.png)\n\n### 마우스와 라인 번호\n\n```lua\nluavim.o.mouse = 'a'\nvim.wo.number = true\nvim.o.relativenumber = true\n```\n\n- `mouse`: 모든 모드에서 마우스 사용 가능. 터미널 환경에서도 클릭, 스크롤이 편리하다.\n- `number` + `relativenumber`: 절대 라인 번호와 상대 라인 번호를 함께 표시한다.\n\n```lua\nvim.o.cursorline = true\nvim.api.nvim_create_autocmd(\"ColorScheme\", {\n  pattern = \"*\",\n  callback = function()\n    vim.api.nvim_set_hl(0, \"CursorLine\", { bg = \"#2d2d2d\" })\n    vim.api.nvim_set_hl(0, \"CursorLineNr\", { fg = \"#ffffaa\", bold = true })\n  end,\n})\n```\n\n- `cursorline`: 현재 커서가 있는 라인을 하이라이트해, 코드 작성 중 현재 위치를 쉽게 파악할 수 있다.\n- `색상 설정`: 디폴트 커서라인 하이라이트가 배경과 크게 차이나지 않아 매뉴얼하게 변경하였다.\n\n\n### 화면 구성\n\n```lua\nluavim.o.signcolumn = 'yes'\nvim.o.wrap = false\nvim.o.linebreak = true\nvim.o.showtabline = 1\nvim.opt.termguicolors = true\n```\n\n- `signcolumn`: Git 변경사항이나 LSP 진단 표시를 위한 컬럼을 항상 표시한다.\n- `wrap`: 긴 줄을 자동으로 줄바꿈하지 않는다.\n- `linebreak`: wrap을 켰을 때 단어 중간에서 끊지 않도록 설정한다.\n- `showtabline`: 탭이 2개 이상일 때만 탭 라인을 표시한다.\n- `termguicolors`: 24비트 트루 컬러를 활성화해 색상 테마가 훨씬 예쁘게 보이게 한다.\n\n## 📏 INDENT - 들여쓰기 설정\n\n![C 파일의 4칸 들여쓰기](image-2.png)\n\n이전 Lua 파일은 2칸 들여쓰기를, 위 사진의 C 파일은 4칸 들여쓰기를 적용하였다.\n\n### 기본 들여쓰기 동작\n\n```lua\nluavim.o.smartindent = true\nvim.o.autoindent = true\nvim.o.breakindent = true\n```\n\n- `smartindent`: C언어 스타일의 스마트한 자동 들여쓰기\n- `autoindent`: 새 줄 생성 시 이전 줄의 들여쓰기를 유지한다.\n- `breakindent`: 줄바꿈 시 들여쓰기를 시각적으로 유지한다.\n\n### 탭과 스페이스\n\n```lua\nluavim.o.shiftwidth = 4\nvim.o.tabstop = 4\nvim.o.softtabstop = 4\n```\n\nNeovim의 디폴트 인덴트는 8칸인데, 익숙하지 않아 가독성이 조금 떨어졌다. 보다 보편적인 4칸 들여쓰기로 변경했다.\n\n### 파일 타입별 설정\n\n```lua\nluavim.api.nvim_create_autocmd(\"FileType\", {\n  pattern = {\"lua\", \"dart\", \"javascript\", \"typescript\", \"typescriptreact\", \"javascriptreact\"},\n  callback = function()\n    vim.opt_local.shiftwidth = 2\n    vim.opt_local.tabstop = 2\n    vim.opt_local.softtabstop = 2\n  end,\n})\n```\n\n2칸 들여쓰기가 더 많이 쓰이는 Lua, JavaScript, TypeScript 등에 대해 인덴트 설정을 따로 해주었다.\n\n## ✏️ EDITING - 편집 설정\n\n```lua\nluavim.o.expandtab = true\nvim.o.backspace = 'indent,eol,start'\nvim.opt.formatoptions:remove { 'c', 'r', 'o' }\n```\n\n- `expandtab`: Tab 키를 누르면 스페이스로 변환해 탭과 스페이스 혼용 문제를 방지한다.\n- `backspace`: 들여쓰기, 줄 끝, 줄 시작 위치에서 자유롭게 백스페이스 사용이 가능하도록 한다.\n- `formatoptions`: 주석 자동 생성 기능을 제거한다.\n\n\n## 🔍 SEARCH - 검색 설정\n\n```lua\nluavim.o.smartcase = true\nvim.o.ignorecase = true\n```\n\n이 두 옵션이 조합되면\n- 소문자로만 검색하면 대소문자 구분 없이 검색하고(`/test` → `Test`, `TEST` 모두 검색), \n- 대문자가 포함되면 대소문자를 구분하게 된다(`/Test` → `Test`만 검색).\n\n## 🗂️ SYSTEM & FILES - 시스템 및 파일 설정\n\n```lua\nluavim.o.clipboard = 'unnamedplus'\nluavim.o.undofile = true\nvim.o.fileencoding = 'utf-8'\nvim.opt.runtimepath:remove '/usr/share/vim/vimfiles'\n```\n\n- `clipboard`: 시스템 클립보드와 Neovim을 연동한다. 다만 이 기능은 완전 리눅스 환경에서만 되는 것 같다. 내 경우 Neovim 내부에서 복사하면 외부로 붙여넣기가 안 되고, 이후에 키 매핑으로 `Ctrl+V`를 `p`와 같은 동작을 하도록 했지만 이전에 시스템에서 복사했던 것이 붙여넣기되었다. 아마도 윈도우에서는 `Ctrl+V`가 무조건 시스템 클립보드에서 붙여넣기하도록 우선순위가 설정되어 있는 것 같다.\n- `undofile`: Undo 히스토리를 파일로 저장해, 파일을 닫았다 열어도 실행 취소 가능하도록 했다.\n- `fileencoding`: 한글 지원을 위해 UTF-8로 파일을 저장한다.\n- `runtimepath`: 설정 오류 방지를 위해 Vim 플러그인 경로를 제거하고 Neovim 전용 환경을 구성한다.\n\n## ✨ 마치며\n\n인덴트 설정을 제외하면 모두 웬만한 Neovim 유저들이 적용하고 있는 설정이기 때문에 일단 추가해두면 유용한 옵션 위주로 모아 보았다. 좋은 구성을 발견하면 계속해서 업데이트할 예정이다.\n\n클립보드가 원하는 대로 작동이 안 되는 것이 좀 아쉬웠다. OSC52 등 이것저것 시도를 해봤는데, 일단 Neovim 내부에서 복사한 것은 `Ctrl+V`가 안 먹고 normal 모드에서 `p`로 붙여넣기하는 방법밖에는 없는 것 같다.\n\n추후에 파티션을 나눠 Linux Mint 등을 깔게 되면.. 그때는 제대로 동작하나 다시 한번 검증을 해 봐야겠다."},{"excerpt":"🚀 들어가며 화면 UI 구성을 마무리할 시간이다. 아직은 코드 화면과 파일 트리밖에 없어서 많이 불편감이 느껴질 텐데, 이제 정말 CUI가 뭔지 볼 수 있다 ㅎㅎ Bufferline은 맨 위에 내가 열어놓은 파일 목록을 확인 할 수 있는 기능이고, statusline은 맨 밑에 각종 메타데이터를 확인할 수 있는 기능이다. 📑 Bufferline:  Buf…","fields":{"slug":"/neovim-buffer-status/"},"frontmatter":{"date":"November 04, 2025","title":"[Neovim] Bufferline, Statusline, Scrollbar 구성","tags":["neovim","ide"]},"rawMarkdownBody":"\n## 🚀 들어가며\n\n화면 UI 구성을 마무리할 시간이다. 아직은 코드 화면과 파일 트리밖에 없어서 많이 불편감이 느껴질 텐데, 이제 정말 CUI가 뭔지 볼 수 있다 ㅎㅎ\n\nBufferline은 맨 위에 내가 열어놓은 파일 목록을 확인 할 수 있는 기능이고, statusline은 맨 밑에 각종 메타데이터를 확인할 수 있는 기능이다.\n\n## 📑 Bufferline: `barbar.nvim`\n\nBufferline이 보이게 하는 플러그인으로는 크게 `bufferline.nvim`과 `barbar.nvim`이 있다. `bufferline.nvim`이 좀 더 보편적으로 사용되고 커스터마이징이 자유로운데, `barbar.nvim`은 단축어로 편리하게 버퍼 간 이동을 할 수 있다는 장점이 있어 `barbar.nvim`을 선택했다.\n\n[`barbar.nvim` Github(클릭)](https://github.com/romgrk/barbar.nvim)의 README에 Lazy를 사용해 플러그인을 설치하는 방법이 다음과 같이 나와 있다.\n\n```lua\n-- [[ lua/plugins/barbar.lua ]]\n\nrequire('lazy').setup {\n  {'romgrk/barbar.nvim',\n    dependencies = {\n      'lewis6991/gitsigns.nvim', -- OPTIONAL: for git status\n      'nvim-tree/nvim-web-devicons', -- OPTIONAL: for file icons\n    },\n    init = function() vim.g.barbar_auto_setup = false end,\n    opts = {\n      -- lazy.nvim will automatically call setup for you. put your options here, anything missing will use the default:\n      -- animation = true,\n      -- insert_at_start = true,\n      -- …etc.\n    },\n    version = '^1.0.0', -- optional: only update when a new 1.x version is released\n  },\n}\n```\n\n### 개인 설정 전체\n\n나의 barbar 플러그인 전체 설정은 다음과 같다.\n\n![모든 설정이 적용된 모습](image-3.png)\n\n```lua\nreturn {\n  'romgrk/barbar.nvim',\n  dependencies = {\n    'lewis6991/gitsigns.nvim', -- OPTIONAL: for git status\n    'nvim-tree/nvim-web-devicons', -- OPTIONAL: for file icons\n  },\n  init = function() vim.g.barbar_auto_setup = false end,\n  opts = {\n    icons = {\n      separator = { left = '│', right = '' },\n      inactive = { separator = { left = '│', right = '' } },\n    },\n\n    -- Sets the maximum padding width with which to surround each tab\n    maximum_padding = 1,\n\n    -- Sets the minimum padding width with which to surround each tab\n    minimum_padding = 1,\n\n    -- Set the filetypes which barbar will offset itself for\n    sidebar_filetypes = {\n      ['neo-tree'] = { event = 'BufWipeout' },\n    },\n  },\n\n  config = function(_, opts)\n    -- 1. 먼저 setup 실행\n    require('barbar').setup(opts)\n\n    -- 2. 색상 덮어쓰기\n    -- 색상 설정\n    local colors = {\n      bg = '#1f1f1f',\n      fg = '#ffffff',\n      blue = '#51afef',\n      orange = '#FF8800',\n      gray = '#5c6370',\n    }\n\n    -- 현재 버퍼 (활성)\n    vim.api.nvim_set_hl(0, 'BufferCurrent', { fg = colors.fg, bg = colors.bg, bold = true })\n    vim.api.nvim_set_hl(0, 'BufferCurrentMod', { fg = colors.orange, bg = colors.bg })\n\n    -- 비활성 버퍼\n    vim.api.nvim_set_hl(0, 'BufferInactive', { fg = colors.gray, bg = '#181818' })\n    vim.api.nvim_set_hl(0, 'BufferInactiveMod', { fg = colors.orange, bg = '#181818' })\n\n    -- 탭라인 배경\n    vim.api.nvim_set_hl(0, 'BufferTabpageFill', { bg = '#181818' })\n\n    -- 구분선\n    vim.api.nvim_set_hl(0, 'BufferCurrentSign', { fg = colors.blue, bg = colors.bg })\n    vim.api.nvim_set_hl(0, 'BufferInactiveSign', { fg = '#3e4452', bg = '#181818' })\n  end,\n\n  version = '^1.9.0', -- optional: only update when a new 1.x version is released\n}\n```\n\n### 구분선(Separator) 설정\n\n버퍼 간의 구분선 문자 기본 설정이 '왼쪽 정렬된 세로선'인데, 파일 트리와 코드 화면 분리선과 위치가 어긋나 보기 좋지 않았다 😖\n\n![Bufferline과 그 밑 구분선이 분리되어 있는 모습](image-2.png)\n\n이를 해결하기 위해 '중앙 정렬된, 더 얇은 세로선'으로 구분선을 변경해 주었다.\n\n```lua\nicons = {\n  separator = { left = '│', right = '' },\n  inactive = { separator = { left = '│', right = '' } },\n}\n```\n\n버퍼가 선택되어 있을 때(`separator`)와 선택되지 않았을 때(`inactive-separator`)를 각각 설정해야 동일하게 적용된다.\n\n### 패딩(Padding) 설정\n\n공간이 충분할 경우 버퍼 크기가 꽤 커지는데, 여백이 너무 많으니 보기 좋지 않아서 각 버퍼 탭 양옆의 여백을 1로 고정했다.\n\n![여백 조절이 적용되지 않은 모습](image-4.png)\n\n```lua\nmaximum_padding = 1,\nminimum_padding = 1,\n```\n\n### 사이드바 오프셋 설정\n\n파일 탐색기 같은 사이드바가 열릴 때 버퍼라인을 자동으로 이동시킨다.\n\n```lua\nsidebar_filetypes = {\n  ['neo-tree'] = { event = 'BufWipeout' },\n}\n```\n\n`nvim-tree` 등 다른 파일 트리 플러그인에 대한 오프셋 설정도 플러그인 리드미에서 확인할 수 있다. 예시는 다음과 같다.\n\n```lua\nsidebar_filetypes = {\n  NvimTree = true,\n  undotree = { text = 'undotree' },\n  Outline = { event = 'BufWinLeave', text = 'symbols-outline' },\n}\n```\n\n### 색상 커스터마이징\n\n`config` 함수에서 highlight 그룹을 직접 설정하여 원하는 색상 테마를 적용할 수 있다.\n\n```lua\nlocal colors = {\n  bg = '#1f1f1f',      -- 활성 버퍼 배경\n  fg = '#ffffff',      -- 활성 버퍼 텍스트\n  blue = '#51afef',    -- 구분선 강조색\n  orange = '#FF8800',  -- 수정 상태 표시\n  gray = '#5c6370',    -- 비활성 텍스트\n}\n```\n\nVSCode 테마가 barbar 플러그인에 최적화되어 있지 않은 것 같아서 `#181818` 등의 색상을 임의 적용했다.\n\n```lua\n-- 활성 버퍼\nvim.api.nvim_set_hl(0, 'BufferCurrent', { fg = colors.fg, bg = colors.bg, bold = true })\nvim.api.nvim_set_hl(0, 'BufferCurrentMod', { fg = colors.orange, bg = colors.bg })\nvim.api.nvim_set_hl(0, 'BufferCurrentSign', { fg = colors.blue, bg = colors.bg })\n\n-- 비활성 버퍼\nvim.api.nvim_set_hl(0, 'BufferInactive', { fg = colors.gray, bg = '#181818' })\nvim.api.nvim_set_hl(0, 'BufferInactiveMod', { fg = colors.orange, bg = '#181818' })\nvim.api.nvim_set_hl(0, 'BufferInactiveSign', { fg = '#3e4452', bg = '#181818' })\n\n-- 탭라인 배경\nvim.api.nvim_set_hl(0, 'BufferTabpageFill', { bg = '#181818' })\n```\n\n색상 적용사항은 다음과 같다.\n\n- 수정사항이 아직 저장되지 않은 버퍼는 **오렌지색 글씨**\n- 활성 버퍼는 **어두운 회색** (코드 스니펫과 같은 색)\n- 비활성 버퍼는 **검은색** (파일 트리와 같은 색)\n\n![오렌지색 버퍼](image-6.png)\n\n설정을 저장하고 Neovim을 재시작했을 때 버퍼라인의 모습이다. \n\n## 💫 Statusline: `lualine`\n\nStatusline은 가장 많이 사용되는 [lualine(클릭)](https://github.com/nvim-lualine/lualine.nvim)으로 결정했다. 우리는 VSCode와 가장 비슷한 테마를 적용해야 하는데, statusline 플러그인 중 테마 호환이 가장 잘 되어 있는 플러그인이 `lualine`이다.\n\n전체 코드는 다음과 같다.\n\n```lua\n-- [[ lua/plugins/lualine.lua ]]\n\nreturn {\n  'nvim-lualine/lualine.nvim',\n  dependencies = { 'nvim-tree/nvim-web-devicons' },\n\n  config = function()\n    -- Variable for small window settings\n    local hide_in_width = function()\n      return vim.fn.winwidth(0) > 100\n    end\n\n    -- Diagnostics: Not shown if small window\n    local diagnostics = {\n      'diagnostics',\n      sources = { 'nvim_diagnostic' },\n      always_visible = false,\n      cond = hide_in_width,\n    }\n\n    -- Git diff icon settings: Not shown if small window\n    local diff = {\n      'diff',\n      cond = hide_in_width,\n    }\n\n    require('lualine').setup {\n      options = {\n        disabled_filetypes = { 'alpha', 'neo-tree' },\n      },\n      sections = {\n        lualine_a = {'mode'},\n        lualine_b = {'branch', diff, diagnostics},\n        lualine_c = {'filename'},\n        lualine_x = {'encoding', 'fileformat', 'filetype'},\n        lualine_y = {'progress'},\n        lualine_z = {'location'}\n      },\n      inactive_sections = {\n        lualine_a = {},\n        lualine_b = {},\n        lualine_c = {'filename'},\n        lualine_x = {'location'},\n        lualine_y = {},\n        lualine_z = {}\n      },\n      tabline = {},\n      winbar = {},\n      inactive_winbar = {},\n      extensions = { 'fugitive' }\n    }\n  end,\n}\n```\n\n### Lazy로 lualine 설치\n\n`lualine.nvim`의 README에 Lazy 매니저로 플러그인을 설치하는 방법이 다음과 같이 나와 았다.\n\n```lua\n{\n  'nvim-lualine/lualine.nvim',\n  dependencies = { 'nvim-tree/nvim-web-devicons' }\n}\n```\n\n### 창 크기에 따라 요소 조절하기\n\nStatusline에 모든 요소가 항상 표시되면, 창 크기를 줄였을 때 중요한 정보들이 표시되지 않을 수 있다. 이를 방지하기 위해 반응형으로 statusline을 구성한다.\n\n`hide_in_width` 함수를 선언해 윈도우 크기가 작아지면 `dianostics`와 `diff` 요소가 표시되지 않도록 했다. 이때 주의할 점은, `sections` 프로퍼티에서 문자열이 아닌 변수를 전달해야 한다.\n\n```lua\nsections = {\n  lualine_a = {'mode'},\n  lualine_b = {'branch', diff, diagnostics},\n  lualine_c = {'filename'},\n  lualine_x = {'encoding', 'fileformat', 'filetype'},\n  lualine_y = {'progress'},\n  lualine_z = {'location'}\n},\n```\n\n![창 크기를 줄인 모습](image-5.png)\n\n반응형 statusline이 적용되면 위 사진과 같이 git 변경사항과 lsp 오류가 있음에도 상태바에 표시되지 않는다.\n\n`lualine_b`에 `diff`와 `diagonstics` 변수를 전달한 것을 볼 수 있다. Statusline의 요소들은 pre-configured 그대로 사용하지 않아도 되고, 마음대로 커스터마이징할 수 있다.\n\n### 파일 트리 오프셋\n\n파일 트리에는 statusline이 나타나지 않게 하고 싶다면 `disabled_filetypes` 프로퍼티에 파일 트리를 추가해주면 된다.\n\n```lua\noptions = {\n  disabled_filetypes = { 'alpha', 'neo-tree' },\n},\n```\n\n![Full Screen](image-7.png)\n\nBufferline과 statusline까지 구성하고 나면 이 정도의 화면이 완성되었을 것! 💃 `disabled_filetypes`에 파일트리를 추가했다면 왼쪽 하단 회색 글씨는 없어진다.\n\n## 📜 Scrollbar: `nvim-scrollbar`\n\n스크롤 자체는 마우스 휠이나 키보드의 'PGDN' 키로 할 때가 많아 괜찮지만, git diff를 스크롤바에서 바로 확인해서 그 위치로 가고 싶을 때가 있다. 검색을 할 때도 여간 불편한 게 아니다.\n\n이를 해결하기 위해 스크롤바 플러그인을 설치하기로 결정했다.\n\nREADME에 lazy 매니저를 활용한 설치 매뉴얼은 공식적으로 나와 있지 않지만 다음 [Github Issue(클릭)](https://github.com/petertriho/nvim-scrollbar/issues/112)에서 힌트를 얻을 수 있었다.\n\n### TBD\n\n스크롤바 플러그인을 몇 개 둘러봤지만,\n\n1. 스크롤바 색상과 너비를 조절할 수 있고\n2. VSCode처럼 파일 길이에 맞춰 스크롤바 크기가 고정되고\n3. 모든 내용이 한 화면 안에 있어도 스크롤바가 사라지지 않는\n\n세 가지 조건을 충족하는 스크롤바를 찾을 수 없었다. 개인적으로 플러그인을 수정해서 구현하기 전까지 이 파트는 최종 설정을 공유할 수 없을 것 같다.\n\n## ✨ 마치며\n\n이제 그럴듯한 화면 구성이 완료되었다. 스크롤바가 맘에 꼭 드는 게 없어서 아쉽지만, 추후에 직접 구현해 보는 것도 재미있을 것 같다. \n\n이대로 개발을 진행해도 되지만 코드 에디터를 쓰는 주된 이유는 빠른 에러 확인이기도 하다. 간단한 문법 오류는 에디터가 잡아내 줘야 생산성이 올라간다. 이후부터는 기능적인 면에 집중해서 IDE 구성을 진행할 예정이다."},{"excerpt":"🚀 들어가며 이제 실제 Neovim 화면을 그럴듯하게 꾸며볼 예정인데, 개인적으로 이 부분이 가장 재미있었다 😄 나는 VSCode에 익숙해서 VSCode 테마를 적용했지만 유저들이 만든 다른 테마들도 굉장히 많다. (사실 다른 테마 이것저것 적용해 봤는데, 다 눈이 너무 피곤했다.. VSCode가 확실히 컬러감을 잘 뽑은 듯.)  dotfyle(클릭)에 …","fields":{"slug":"/neovim-theme/"},"frontmatter":{"date":"November 03, 2025","title":"[Neovim] Neovim을 VSCode처럼 꾸며보자","tags":["neovim","ide"]},"rawMarkdownBody":"\n## 🚀 들어가며\n\n이제 실제 Neovim 화면을 그럴듯하게 꾸며볼 예정인데, 개인적으로 이 부분이 가장 재미있었다 😄\n\n나는 VSCode에 익숙해서 VSCode 테마를 적용했지만 유저들이 만든 다른 테마들도 굉장히 많다. (사실 다른 테마 이것저것 적용해 봤는데, 다 눈이 너무 피곤했다.. VSCode가 확실히 컬러감을 잘 뽑은 듯.)\n\n![dotfyle: Trending Neovim Colorschemes](image.png)\n\n[dotfyle(클릭)](https://dotfyle.com/neovim/colorscheme/top)에 접속하면 여러 테마를 살펴볼 수 있다. \n\n## ✍️ 폰트 설정\n\n테마를 설정하기 전, 아이콘 지원을 위해 [Nerd Font Famliy(클릭)](https://www.nerdfonts.com/)를 설치한다.\n\n![nerd fonts](image-1.png)\n\n### 폰트 다운로드\n\nDownloads 버튼을 클릭해 다운로드 페이지로 접속한다. 여러 폰트들이 있는데, 나는 `JetBrainsMono Nerd Font`를 선택했다. \n\n다운로드받고 압축을 풀면 여러 크기의 폰트 파일들이 있다. Light 폰트가 적용했을 때 가장 부담스럽지 않기 때문에 이 폰트만 설치하는 것을 권장한다.\n\n![JetBrainsMono Nerd Font](image-2.png)\n\n⚠️주의⚠️: 뒤에 `Mono` 나 `Propo`가 붙어 있는 파일이 아닌 `JetBrainsMonoNerdFont`라고만 되어 있는 파일을 설치할 것! 다른 파일들은 아이콘이 작게 출력되는 문제가 생긴다.\n\n### 터미널에 폰트 적용\n\n![터미널 설정](image-3.png)\n\n윈도우 기준으로 설명하면, cmd 창을 켜고 상단 바에서 우클릭해 설정에 들어간다.\n\n![기본값 > 모양 > 글꼴](image-4.png)\n\n왼쪽 사이드바에서 '기본값'을 선택하고 '모양' 탭에 들어가 글꼴을 JetBrainsMono Nerd Font로 설정해주고, 크기와 높이를 선호에 맞게 조절한다.\n\n우측 하단 '저장'을 누르고 다시 터미널로 돌아가면 변경사항이 적용된다!\n\n## 🌈 `vscode.nvim` 테마 플러그인 설치\n\n이제 본격적으로 테마를 설정할 차례이다 😆\n\n[vscode.nvim(클릭)](https://github.com/Mofiqul/vscode.nvim?tab=readme-ov-file)은 lazy 방식의 플러그인 설치에 대한 매뉴얼을 제공하고 있지 않다. 다음과 같이 작성하면 된다.\n\n```lua\n--[[ lua/plugins/colorscheme.lua ]]\n\nreturn {\n  'Mofiqul/vscode.nvim',\n  lazy = false,\n  priority = 1000,\n  config = function()\n    local c = require('vscode.colors').get_colors()\n    require('vscode').setup({\n      -- Alternatively set style in setup\n      -- style = 'light'\n\n      -- Enable transparent background\n      transparent = false,\n\n      -- Enable italic comment\n      italic_comments = true,\n\n      -- Enable italic inlay type hints\n      italic_inlayhints = true,\n\n      -- Underline `@markup.link.*` variants\n      underline_links = true,\n\n      -- Disable nvim-tree background color\n      disable_nvimtree_bg = true,\n\n      -- Apply theme colors to terminal\n      terminal_colors = true,\n\n      -- Override colors (see ./lua/vscode/colors.lua)\n      color_overrides = {\n        vscLineNumber = '#FFFFFF',\n      },\n\n      -- Override highlight groups (see ./lua/vscode/theme.lua)\n      group_overrides = {\n        -- this supports the same val table as vim.api.nvim_set_hl\n        -- use colors from this colorscheme by requiring vscode.colors!\n        Cursor = { fg=c.vscDarkBlue, bg=c.vscLightGreen, bold=true },\n      }\n    })\n    vim.cmd.colorscheme('vscode')\n  end\n}\n```\n\n이전에 플러그인을 설치할 때와는 다른 점이 있는데, 바로 다음 대목이다.\n\n```lua\nlazy = false\npriority = 1000\n```\n\n이 부분들은 테마가 지연 로딩되지 않도록 한다. 우선순위를 높게 설정해주어 테마가 항상 가장 먼저 적용되어 우리 눈에 보이도록 하는 설정이다.\n\n![vscode.nvim](image-5.png)\n\n플러그인을 추가하고 Neovim을 재시작하면 사진처럼 VSCode와 동일한 컬러가 나타난다. \n\n중괄호 색이 다 똑같이 파란색이라는 게 아쉽지만..🥲 인덴트를 표시해주면 쓸만하다. 레인보우로 중괄호를 표시해주는 플러그인이 있긴 한데, 어지러울 것 같아서 나는 설치하지 않았다.\n\n## 📐 인덴트 표시하기\n\nVSCode 스타일의 테마를 적용한다고 바로 인덴트 보조선이 나타나진 않고, 플러그인을 설치해야 한다.\n\n가장 보편적인 플러그인은 [indent-blankline(클릭)](https://github.com/lukas-reineke/indent-blankline.nvim)이다. README에 lazy로 설치하는 방법이 나와 있다.\n\n```lua\n--[[ lua/plugins/indent-blankline.lua ]]\n\nreturn {\n  'lukas-reineke/indent-blankline.nvim',\n  main = 'ibl',\n  ---@module \"ibl\"\n  ---@type ibl.config\n  opts = {\n    indent = {\n      char = \"▏\",\n    },\n    scope = {\n      enabled = false,\n    },\n  },\n}\n```\n\n기본으로 적용되는 기호가 너무 두꺼워서 옵션을 수정해 좀 더 얇은 기호로 변경했다.\n\n저장하고 재시작하면 이전 사진처럼 예쁜 인덴트 보조선이 나타난다! 보조선 또한 무지개색으로 설정 가능하니 원한다면 적용해봐도 좋을 것 같다.\n\n## 🖌️ 파일 트리 테마 수정\n\nVSCode에서는 파일 트리가 코드 스니펫보다 어둡다. 이를 반영하기 위해 한 가지 수정사항을 추가한다.\n\n```lua\n--[[ lua/plugins/colorscheme.lua ]]\n\n-- Override highlight groups (see ./lua/vscode/theme.lua)\ngroup_overrides = {\n  -- this supports the same val table as vim.api.nvim_set_hl\n  -- use colors from this colorscheme by requiring vscode.colors!\n  Cursor = { fg=c.vscDarkBlue, bg=c.vscLightGreen, bold=true },\n\n  -- Neo-tree 배경색 추가\n  NeoTreeNormal = { bg = \"#181818\" },\n  NeoTreeNormalNC = { bg = \"#181818\" },\n}\n```\n\n`group_overrides` 프로퍼티 안에 neo-tree의 기본/포커스 시 색상 설정을 추가한다.\n\n![neo-tree color](image-6.png)\n\n이제 파일 트리 색상까지 정상적으로 적용되었다.\n\n## ✨ 마치며\n\n이제 VSCode와 비슷한 UI가 완성되었다! 🎉\n\nNeovim을 구성하는 데 걸림돌이 되는 것 중 하나가 눈에 익지 않은 컬러감과 요소 배치라고 생각한다. 개인적으로 잘 만들어진 UI도 익숙함을 이길 수 없다고 생각하기 때문에.. 더 나은 걸 찾기보다는 내가 몇 년 간 익숙해진 VSCode를 똑같이 따라하는 데 주안점을 뒀다.\n\n다음 포스트에서 Bufferline과 StatusLine을 구성하면 이제 화면 관련된 설정은 끝난다."},{"excerpt":"🚀 들어가며 Neovim을 설치했으니 이제 나만의 configuration을 시작해볼 차례다. 가장 기본이 되는 플러그인 매니저 설치부터 시작한다. 💪 Neovim이 처음 나왔을 때에 주로 사용되던 매니저는 이다. 이전의 Vundle이나 Pathogen 같은 매니저들보다 훨씬 단순하고 설정이 간편했지만 VimScript 기반이라는 한계가 있었다. Neov…","fields":{"slug":"/neovim-lazy-neotree/"},"frontmatter":{"date":"October 30, 2025","title":"[Neovim] Lazy.nvim 플러그인 매니저와 파일 트리 설치","tags":["neovim","ide"]},"rawMarkdownBody":"\n## 🚀 들어가며\n\nNeovim을 설치했으니 이제 나만의 configuration을 시작해볼 차례다. 가장 기본이 되는 플러그인 매니저 설치부터 시작한다. 💪\n\nNeovim이 처음 나왔을 때에 주로 사용되던 매니저는 `vim-plug`이다. 이전의 Vundle이나 Pathogen 같은 매니저들보다 훨씬 단순하고 설정이 간편했지만 VimScript 기반이라는 한계가 있었다.\n\nNeovim의 Lua 지원을 활용하기 위해 개발된 것이 `packer`이다. Lua는 Vimscript보다 빠르고 효율적이며, 현대적인 프로그래밍 언어의 기능들을 제공한다.\n\n요즘 보편적으로 사용하는 플러그인 매니저는 `lazy.nvim`이다. 코드가 간결하고 이해하기 쉬우며, 지연 로딩(lazy loading) 최적화로 매우 빠른 실행 속도를 자랑한다.\n\n## 🔌 Lazy.nvim 설치\n\n### 초기 설치 코드 작성\n\nKickstart의 `init.lua` 파일에서 다음 부분을 복사헤, 나의 `init.lua`에 붙여넣기한다. Line 200 초중반에 있고, `lazy` 키워드로 검색하면 편하다.\n\n```lua\n-- [[ Install `lazy.nvim` plugin manager ]]\n--    See `:help lazy.nvim.txt` or https://github.com/folke/lazy.nvim for more info\nlocal lazypath = vim.fn.stdpath 'data' .. '/lazy/lazy.nvim'\nif not (vim.uv or vim.loop).fs_stat(lazypath) then\n  local lazyrepo = 'https://github.com/folke/lazy.nvim.git'\n  local out = vim.fn.system { 'git', 'clone', '--filter=blob:none', '--branch=stable', lazyrepo, lazypath }\n  if vim.v.shell_error ~= 0 then\n    error('Error cloning lazy.nvim:\\n' .. out)\n  end\nend\n\n---@type vim.Option\nlocal rtp = vim.opt.rtp\nrtp:prepend(lazypath)\n\n-- [[ Configure and install plugins ]]\n--\n--  To check the current status of your plugins, run\n--    :Lazy\n--\n--  You can press `?` in this menu for help. Use `:q` to close the window\n--\n--  To update plugins you can run\n--    :Lazy update\n--\n-- NOTE: Here is where you install your plugins.\nrequire('lazy').setup({\n```\n\n주석은 최소한으로 남기고 지우는 것을 권장한다.\n\n```lua\n-- [[ init.lua ]]\n\n-- [[ Install `lazy.nvim` plugin manager ]]\nlocal lazypath = vim.fn.stdpath 'data' .. '/lazy/lazy.nvim'\nif not (vim.uv or vim.loop).fs_stat(lazypath) then\n  local lazyrepo = 'https://github.com/folke/lazy.nvim.git'\n  local out = vim.fn.system { 'git', 'clone', '--filter=blob:none', '--branch=stable', lazyrepo, lazypath }\n  if vim.v.shell_error ~= 0 then\n    error('Error cloning lazy.nvim:\\n' .. out)\n  end\nend\n\n---@type vim.Option\nlocal rtp = vim.opt.rtp\nrtp:prepend(lazypath)\n\n-- [[ Configure and install plugins ]]\nrequire('lazy').setup('plugins')\n```\n\n### 플러그인 설치 방식\n\n플러그인 설치 코드를 작성하는 방법은 두 가지가 있다.\n\n**1. `plugins` 폴더에 있는 모든 플러그인을 무조건 설치한다.**\n\n플러그인은 `lua/plugins/` 폴더에서 관리한다. 다음과 같이 코드를 작성하면 해당 폴더의 모든 플러그인이 항상 설치된다.\n\n```lua\nrequire('lazy').setup('plugins')\n```\n\n**2. 설치할 플러그인을 명시적으로 설정한다.**\n\n플러그인 폴더에서 원하는 플러그인들을 직접 작성한다. \n\n사용하지 않는 플러그인을 삭제하지 않고 백업용으로 둘 수 있다는 장점이 있는 반면에, 새로운 플러그인을 추가할 때는 다소 귀찮다는 단점이 있다. 나는 플러그인 추가 코드를 작성하는 걸 자꾸 까먹어서..😅 그냥 1번 방법으로 한꺼번에 추가하고 있다.\n\n```lua\nrequire('lazy').setup({\n  require 'plugins.telescope',\n  require 'plugins.treesitter',\n})\n```\n\n## 📂 파일 트리 설치\n\n첫 플러그인으로 파일 트리 중 하나인 [neo-tree(클릭)](https://github.com/nvim-neo-tree/neo-tree.nvim) 플러그인을 설치한다. 파일 트리 플러그인에는 neo-tree와 nvim-tree가 제일 많이 사용되는데, neo-tree가 더 현대적인 기능이 많다.\n\n```lua\n-- [[ lua/plugins/neotree.lua ]]\n\nreturn {\n  \"nvim-neo-tree/neo-tree.nvim\",\n  branch = \"v3.x\",\n  dependencies = {\n    \"nvim-lua/plenary.nvim\",\n    \"MunifTanjim/nui.nvim\",\n    \"nvim-tree/nvim-web-devicons\", -- optional, but recommended\n  },\n  lazy = false, -- neo-tree will lazily load itself\n}\n```\n\n위와 같이 `neotree.lua` 파일을 작성하고 Neovim을 다시 실행하면 플러그인이 설치된다.\n\n![neo-tree](image.png)\n\n`:Neotree` 명령어로 파일 트리를 켜고, `:Neotree close`로 닫을 수 있다. 이는 추후에 단축키로 옮길 예정이다.\n\n![Create new file](image-1.png)\n\n폴더에 포커스가 주어진 상태에서 `a`키를 누르면 새로운 파일이나 디렉토리를 만들 수 있다. 이름을 입력하고 마지막에 슬래시(`/`)를 붙이면 디렉토리가 생성된다.\n\n## 🖌️ Neo-Tree 커스터마이징\n\n처음 설치한 파일트리는 각종 불필요한 Git 아이콘들이 중복되어 표시되는 등 불편함이 많다. 이를 VSCode 스타일로 변경한다.\n\n### Filtered files 모두 표시\n\nneotree는 기본적으로 dotfiles와 gitignore 파일을 숨긴다. 그러나 이 파일들이 파일 트리에 표시되어야 편할 때가 많아서, 숨김 옵션을 명시적으로 비활성화해 주었다.\n\n`opts` 중괄호 안에 다음과 같이 설정한다.\n\n```lua\nfilesystem = {\n  filtered_items = {\n    visible = true,\n    dotfiles = false, -- .으로 시작하는 파일 항상 보기\n    git_ignored = false, -- gitignore된 파일 항상 보기\n  }\n},\n```\n\n### Git status와 색상 설정\n\nVSCode의 경우 `Untracked`와 `Added`가 모두 초록색, `Modified`가 노란색, 기타 에러가 빨간색이다. 이를 반영하는 동시에 혼잡한 아이콘을 모두 동일한 원 아이콘으로 바꿔서 가독성을 높이려고 한다.\n\n![VSCode File Tree](image-2.png)\n\n`lazy = false` 이후 라인에 `opts = {}`를 추가하고 중괄호 안에 다음 옵션들을 추가한다.\n\n```lua\nenable_diagnostics = false,  -- Disable warning/error icons\ndefault_component_configs = {\n  git_status = {\n    symbols = {\n      added = \"●\",\n      modified = \"●\",\n      deleted = \"●\",\n      renamed = \"●\",\n      untracked = \"●\",\n      ignored = \"\",\n      unstaged = \"\",\n      staged = \"\",\n      conflict = \"●\",\n    },\n  },\n},\n```\n\nDiagnostics가 파일 트리에까지 뜨면 정신이 없어서 꺼버렸고, 아이콘을 모두 점으로 통일했다.\n\n```lua\nconfig = function(_, opts)\n  require(\"neo-tree\").setup(opts)\n\n  -- Git 색상 설정 (VSCode 스타일)\n  vim.cmd([[\n    highlight NeoTreeGitModified guifg=#E2C08D \n    highlight NeoTreeGitUntracked guifg=#73C991\n    highlight NeoTreeGitAdded guifg=#73C991\n    highlight NeoTreeGitDeleted guifg=#E06C75\n    highlight NeoTreeGitConflict guifg=#E06C75\n\n    highlight NeoTreeDotFile guifg=#8C8C8C\n    highlight NeoTreeFilteredItem guifg=#8C8C8C\n  ]])\n```\n\n색상 설정은 `require(\"neo-tree\").setup(opts)`로 기본 옵션을 적용한 후에 덧입혀야 한다. \n\nGit status 관련 파일들은 VSCode와 같은 색상으로, filtered 파일들은 회색으로 설정했다. 설정하고 나면 다음과 같이 아름답게😘 나타난다.\n\n![Customized neotree](image-4.png)\n\n### 파일 트리 자동 토글\n\n그리고 Neovim을 처음 켜면 파일 트리가 닫혀 있는데, 이게 불편해서 자동으로 파일 트리가 토글되도록 했다.\n\n```lua\n  -- Nvim이 시작될 때 Neo-tree를 자동으로 엽니다.\n  vim.api.nvim_create_autocmd(\"VimEnter\", {\n    pattern = \"*\",\n    -- 중복 실행을 방지하기 위해 새 그룹 생성\n    group = vim.api.nvim_create_augroup(\"neotree_on_startup\", { clear = true }),\n    callback = function()\n      vim.cmd(\"Neotree\")\n    end\n  })\n\nend,\n```\n\n## ✨ 마치며\n\n처음 Neo-tree를 설치하면 파일 앞 아이콘이 깨져 보일 수 있다. 터미널 설정 폰트가 아이콘을 지원하지 않기 때문인데, 이는 `nerd font`를 설치하면 해결 가능하다.\n\n다음 포스트에서 폰트 설정을 포함해 기본 UI 설정을 다룰 예정이다."},{"excerpt":"🚀 들어가며 본 포스트는 Neovim 설치 과정과 간단한 configuration을 담고 있습니다. 여기서 진행하는 설정은 모두 리셋하고 다시 personal config를 셋업할 예정이니 참고하시기 바랍니다. 여러 환경 문제로 VSCode를 사용할 수 없는 난관에 빠졌다.. 개발을 하면서 GUI를 사용할 수 없다니.. 말도 안 돼 😱😱 되는 대로 vim…","fields":{"slug":"/neovim-start/"},"frontmatter":{"date":"October 29, 2025","title":"[Neovim] Neovim 설치 및 맛보기","tags":["neovim","ide"]},"rawMarkdownBody":"\n## 🚀 들어가며\n\n본 포스트는 Neovim 설치 과정과 간단한 configuration을 담고 있습니다. 여기서 진행하는 설정은 모두 리셋하고 다시 personal config를 셋업할 예정이니 참고하시기 바랍니다.\n\n---\n\n<br>\n\n여러 환경 문제로 VSCode를 사용할 수 없는 난관에 빠졌다.. 개발을 하면서 GUI를 사용할 수 없다니.. 말도 안 돼 😱😱 \n\n되는 대로 vim 에디터를 쓰다가 생산성이 너무 떨어져 대안을 찾아 나섰다. 그렇게 추천받은 에디터가 CUI를 사용하는 Neovim이다. \n\n처음에는 예쁜 디자인에 끌려 NvChad 디스트로를 설치해 사용해 보았는데, 이미 모든 configuration이 완성되어 있다 보니 나에게 익숙하지 않은 키맵이 너무 많아 그냥 raw vim을 쓰는 것과 크게 다르지 않게 느껴졌다.\n\n### Full Neovim Setup from Scratch\n\n> 썸네일을 클릭하면 유튜브 영상을 시청하실 수 있습니다.\n\n[![Full Neovim Setup from Scratch](https://img.youtube.com/vi/KYDG3AHgYEs/maxresdefault.jpg)](https://youtu.be/KYDG3AHgYEs?si=zX4IFnZvH9rJVbW7)\n\n나에게 익숙한 건 단연 VSCode. Neovim을 VSCode 및 윈도우 환경과 최대한 비슷하게 구축하는 것을 목표로 삼고, 위 유튜브 영상을 참고해 커스터마이징을 시작했다!\n\n`Neovim으로 개발환경 구축하기` 시리즈에서는 위 영상을 일부 번역하는 동시에 나의 개인 설정을 기록하려 한다. 영상이 매우 잘 설명되어 있어서, 혹시 이 게시물을 참고한다면 영상 또한 시청하는 것을 권장한다.\n\n### 나의 Neovim dotfile\n\n이번 시리즈에 나오는 모든 코드는 [나의 Github repository(클릭)](https://github.com/zunione/nvim)에서 확인할 수 있다.\n\n## 📥 Neovim 최신 Release 다운로드\n\n### 우분투 패키지 다운로드\n\n우분투 패키지 매니저에서 다운로드받을 수 있다. 다만 내가 했을 때는 v0.6.1이 다운로드되는 불상사가 발생했다. 😅\n\n최신 Neovim은 v0.11.x이며 deprecated된 요소들이 있으므로, 다음 목차에서 소스 코드로 다운로드받는 것을 권장한다.\n\n```bash\nsudo apt update\nsudo apt install neovim\nnvim --version\n```\n\n```\nNVIM v0.6.1\nBuild type: Release\nLuaJIT 2.1.0-beta3\nCompiled by team+vim@tracker.debian.org\n\nFeatures: +acl +iconv +tui\nSee \":help feature-compile\"\n\n   system vimrc file: \"$VIM/sysinit.vim\"\n  fall-back for $VIM: \"/usr/share/nvim\"\n\nRun :checkhealth for more info\n```\n\n### 소스 코드로부터 다운로드\n\n[Neovim Release(클릭)](https://github.com/neovim/neovim/releases) 페이지에서 `nvim-linux-x86_64.tar.gz` 파일을 다운로드한다.\n\nappimage 파일 자체를 다운로드하는 방법과 압축 파일을 다운로드 하는 방법이 있는데, TAR 압축 파일을 해제하는 것이 더 전통적이다.\n\n```bash\ncd /usr/bin/\n# Latest stable release가 업데이트되었다면 해당 파일을 다운로드한다.\n(sudo) wget https://github.com/neovim/neovim/releases/download/v0.11.4/nvim-linux-x86_64.tar.gz\n(sudo) tar xzvf nvim-linux-x86_64.tar.gz\n(sudo) rm nvim-linux-x86_64.tar.gz\necho \"PATH=/usr/bin/nvim-linux-x86_64/bin:$PATH\" >> ~/.bashrc\nsource ~/.bashrc\n```\n\n설치 이후 설정 커스텀을 위한 디렉토리를 생성하고, PATH 정상 등록과 Neovim 버전을 확인한다.\n\n```bash\nmkdir -p ~/.config/nvim\ncd ~/.config/nvim\nwhich nvim\nnvim --version\n```\n\n## 👀 Neovim custom config 맛보기\n\n맛보기 부분은 추후 모두 삭제(`rm -rf`)하고 다시 설정을 진행하게 되니 참고용으로만 활용하면 된다.\n\n### `init.lua` 생성\n\nNeovim의 커스텀 설정은 `~/.config/nvim` 디렉토리에서 이루어지며, 시작점은 `init.lua` 파일이다.\n\n```bash\ncd ~/.config/nvim\ntouch init.lua\nnvim init.lua\n```\n\n```lua\n-- [[ init.lua ]]\n\n-- Enable line number\nvim.wo.number = true\n```\n\n`vim.wo.number`는 vim의 `:set number`와 같은 기능을 하는 설정이다. 이를 저장하고 다시 `nvim` 명령어를 실행하면 사진과 같이 라인 넘버가 나타난다.\n\n![init.lua](image.png)\n\n### 개인 설정을 `options.lua`에서 설정하기\n\n`vim.wo.number`와 같은 설정들을 `options.lua` 파일에 한 데 모아 관리할 수 있다. `init.lua`는 프로그램의 시작점이므로 개인 옵션들은 따로 파일로 빼는 것이 바람직하다.\n\n```bash\ncd ~/.config/nvim\nmkdir lua\ncd lua\ntouch options.lua\nnvim options.lua\n```\n\n```lua\n-- [[ init.lua ]]\n\nrequire 'options'\n```\n\n```lua\n-- [[ lua/options.lua ]]\n\n-- Enable line number\nvim.wo.number = true\n```\n\n이후 `nvim` 명령어를 입력하면 이전과 동일하게 라인 넘버가 나타난다.\n\n## ⚡ `kickstart.nvim`으로 플러그인 맛보기\n\n`kickstart.nvim`은 Neovim 커스터마이징의 시작점을 제공하며, LSP 등 복잡한 코드를 요구하는 설정들이 매우 잘 구현되어 있어 참고하기에 좋다. 이후 몇몇 플러그인을 설치할 때 kickstart를 참고할 예정이다.\n\n### Kickstart 시작하기\n\n`nvim` 디렉토리를 삭제하고 `kickstart.nvim`을 클론해서 살펴본다. 이 또한 추후 삭제하게 된다.\n\n```bash\ncd ~/.config\nrm -rf nvim\ngit clone https://github.com/nvim-lua/kickstart.nvim.git nvim\ncd nvim\nnvim init.lua\n```\n\n![lazy.nvim](image-1.png)\n\nNeovim을 실행하면 사진과 같이 플러그인들이 설치된다. 이때 플러그인 매니저는 `lazy.nvim`을 사용하게 된다. 이전까지 사용되던 매니저는 `vim.plug`나 `packer`였는데, 코드나 구조가 다소 복잡해 대안으로 개발된 프로그램이 `lazy.nvim`이고, 이제는 가장 보편적으로 사용되고 있다.\n\n위 사진에 보이는 화면이 `lazy.nvim`의 플러그인 매니저 창이고, `:Lazy` 명령어로 켤 수 있다.\n\n![init.lua](image-2.png)\n\n`q` 버튼으로 `lazy`의 창을 닫으면 위 사진과 같은 주석과 함께 `init.lua` 파일이 보이게 된다. \n\nkickstart는 특정 배포 버전이 아니라 개인 설정을 위한 시작점을 제공한다는 내용으로 시작하며, 이 `init.lua` 파일의 각종 주석을 잘 읽으면 굉장한 인사이트를 얻을 수 있다! 👻\n\n### 플러그인 추가하기\n\n`init.lua` 파일의 Line 900 중반에 파일 트리 플러그인을 추가할 수 있도록 하는 주석이 있다. 이를 주석 해제한다.\n\n```lua\n-- other plugins..\nrequire 'kickstart.plugins.neo-tree',\n-- other plugins..\n```\n\n저장하고 Neovim을 재시작하면 플러그인이 설치된다. kickstart의 파일 트리 토글 버튼은 `/`(백슬래시)로, 백슬래시를 누르면 파일 트리가 열린다.\n\n![neo-tree](image-3.png)\n\n파일 트리 플러그인 추가 코드에서 조금 더 밑으로 내려가면 커스텀 플러그인을 import할 수 있는 코드가 있다. 여기를 주석 해제하면 `lua/custom/plugins` 디렉토리에 있는 모든 플러그인이 설치된다.\n\n```lua\n-- { import = 'custom.plugins' },\n```\n\n## ✨ 마치며\n\n이제 진짜 custom config를 위해 kickstart도 지워주면 된다. 추후에 코드를 참고하기 위해 다른 디렉토리로 옮겨도 무방한데, 나는 github에서 바로바로 보는 게 편해서 아예 지워 버렸다.\n\nNeovim을 설정하면서 느낀 건, 설정하는 데는 시간이 좀 걸리지만 확실히 편하다! 나는 맥이랑 윈도우를 모두 사용하는데, 단축키를 내 마음대로 설정할 수 있다 보니 맥/윈도우 단축키 중 내가 편하다고 느끼는 것들을 모두 Neovim에 이식했다.\n\n확실히 개발자는.. 이런 게 제일 재밌는 것 같다 ㅎㅎ"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}