{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"WSL2 인터넷 연결 오류 해결: \"Could not resolve host\" 완벽 가이드 🚨 문제 상황 WSL2(Windows Subsystem for Linux 2)에서 을 시도했을 때 다음과 같은 오류가 발생했습니다: 도 불가능하고, 완전히 인터넷 연결이 차단된 상태였습니다. 🔍 진단 과정 1단계: 기본 네트워크 상태 확인 진단 결과: 발견된 문제점…","fields":{"slug":"/neovim-error/"},"frontmatter":{"date":"October 29, 2026","title":"[NeoVim] 플러그인 설치 중 인터넷 연결 유실","tags":["neovim","ide"]},"rawMarkdownBody":"\n# WSL2 인터넷 연결 오류 해결: \"Could not resolve host\" 완벽 가이드\n\n## 🚨 문제 상황\n\nWSL2(Windows Subsystem for Linux 2)에서 `git clone`을 시도했을 때 다음과 같은 오류가 발생했습니다:\n\n```bash\nzunione@101-24031:~$ git clone https://github.com/zunione/nvim\nCloning into 'nvim'...\nfatal: unable to access 'https://github.com/zunione/nvim/': Could not resolve host: github.com\n```\n\n`apt install`도 불가능하고, 완전히 인터넷 연결이 차단된 상태였습니다.\n\n## 🔍 진단 과정\n\n### 1단계: 기본 네트워크 상태 확인\n\n```bash\n# IP 주소 확인\nip addr show\n\n# 라우팅 테이블 확인\nip route show\n\n# DNS 설정 확인\ncat /etc/resolv.conf\n\n# 게이트웨이 핑 테스트\nping -c 4 8.8.8.8\n```\n\n**진단 결과:**\n```\n2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500\n    inet 172.23.214.54/20 brd 172.23.223.255 scope global eth0\n    \ndefault via 172.23.208.1 dev eth0 proto kernel\n172.23.208.0/20 dev eth0 proto kernel scope link src 172.23.214.54\n\nnameserver 127.0.0.53\n\nPING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.\n--- 8.8.8.8 ping statistics ---\n4 packets transmitted, 0 received, 100% packet loss, time 3064ms\n```\n\n**발견된 문제점:**\n- ❌ 외부 인터넷 연결 실패 (100% 패킷 손실)\n- ❌ 게이트웨이 `172.23.208.1`에 도달 불가\n\n### 2단계: 게이트웨이 연결 테스트\n\n```bash\nping -c 4 172.23.208.1\n```\n\n**결과:** 게이트웨이 자체가 응답하지 않음 → WSL 네트워크 브릿지 문제 확정\n\n### 3단계: Windows 네트워크 상태 확인\n\nWindows PowerShell에서 `ipconfig` 실행:\n\n```\nIPv4 주소: 10.10.10.34\n서브넷 마스크: 255.255.255.0\n기본 게이트웨이: 172.25.2.254\n```\n\n**결정적 단서 발견:**\n- Windows PC: `10.10.10.34` (게이트웨이: `172.25.2.254`)\n- WSL: `172.23.214.54` (게이트웨이: `172.23.208.1`)\n\n**→ WSL이 자체 가상 네트워크에 격리되어 Windows의 실제 네트워크에 접근하지 못하고 있음**\n\n## 🎯 근본 원인 분석\n\n### 문제 1: WSL2 네트워크 격리\n\nWSL2는 기본적으로 **NAT(Network Address Translation)** 방식으로 동작하며, Hyper-V를 통해 자체 가상 네트워크를 생성합니다. 이 과정에서 Windows 네트워크와의 브릿지가 제대로 구성되지 않으면 WSL이 외부 인터넷에 접근할 수 없게 됩니다.\n\n**주요 원인:**\n- Hyper-V Virtual Ethernet Adapter 오류\n- Windows 네트워크 스택 충돌\n- VPN 소프트웨어 간섭\n- 방화벽/보안 소프트웨어 차단\n\n### 문제 2: DNS 해석 실패\n\nWSL2는 `systemd-resolved`를 통해 DNS를 관리하는데, `/etc/resolv.conf`가 stub resolver(`127.0.0.53`)를 가리키고 있었습니다. 네트워크 브릿지가 끊어진 상태에서는 이 stub resolver가 실제 DNS 서버로 쿼리를 전달할 수 없습니다.\n\n## ✅ 해결 방법\n\n### Step 1: Windows 네트워크 스택 재설정\n\n**Windows PowerShell (관리자 권한)에서 실행:**\n\n```powershell\n# Winsock 카탈로그 재설정\nnetsh winsock reset\n\n# TCP/IP 스택 재설정\nnetsh int ip reset\n```\n\n실행 후 Windows 재부팅이 필요합니다.\n\n### Step 2: WSL2 네트워크 모드 변경\n\n**Windows에서 `.wslconfig` 파일 생성/수정:**\n\n```powershell\nnotepad $env:USERPROFILE\\.wslconfig\n```\n\n다음 내용 추가:\n\n```ini\n[wsl2]\nnetworkingMode=mirrored\ndnsTunneling=true\nfirewall=true\nautoProxy=true\n```\n\n**각 옵션 설명:**\n- `networkingMode=mirrored`: WSL이 Windows 네트워크를 직접 미러링하여 사용\n- `dnsTunneling=true`: DNS 쿼리를 Windows DNS로 터널링\n- `firewall=true`: Windows 방화벽 규칙 적용\n- `autoProxy=true`: Windows 프록시 설정 자동 적용\n\n저장 후 WSL 재시작:\n\n```powershell\nwsl --shutdown\n```\n\n### Step 3: WSL에서 네트워크 상태 확인\n\nWSL을 다시 시작한 후:\n\n```bash\nroute -n\n```\n\n**변경 후 라우팅 테이블:**\n\n```\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         172.25.2.254    0.0.0.0         UG    291    0        0 eth0\n10.10.10.0      0.0.0.0         255.255.255.0   U     291    0        0 eth0\n172.25.2.0      0.0.0.0         255.255.255.0   U     291    0        0 eth0\n172.25.2.254    0.0.0.0         255.255.255.255 UH    291    0        0 eth0\n```\n\n✅ 이제 Windows의 실제 게이트웨이 `172.25.2.254`를 사용하고 있습니다!\n\n### Step 4: DNS 문제 해결\n\n네트워크 모드가 변경되었지만 여전히 DNS 해석이 안 될 수 있습니다:\n\n```bash\ncurl -I https://github.com\n# curl: (6) Could not resolve host: github.com\n```\n\n**원인:** `/etc/resolv.conf`가 여전히 systemd-resolved의 stub resolver를 가리키고 있음\n\n**해결:**\n\n```bash\n# 1. WSL 자동 DNS 설정 비활성화\nsudo nano /etc/wsl.conf\n```\n\n다음 내용 추가:\n\n```ini\n[network]\ngenerateResolvConf = false\n```\n\n```bash\n# 2. 기존 resolv.conf 삭제 (심볼릭 링크)\nsudo rm /etc/resolv.conf\n\n# 3. 새로운 DNS 설정 파일 생성\nsudo bash -c 'cat > /etc/resolv.conf << EOF\nnameserver 8.8.8.8\nnameserver 8.8.4.4\nnameserver 1.1.1.1\nEOF'\n```\n\n**DNS 서버 설명:**\n- `8.8.8.8` / `8.8.4.4`: Google Public DNS\n- `1.1.1.1`: Cloudflare DNS\n\n### Step 5: 연결 확인\n\n```bash\n# DNS 해석 테스트\ncurl -I https://github.com\n\n# 성공 시 HTTP/2 200 응답\nHTTP/2 200\ndate: Tue, 28 Oct 2025 00:04:38 GMT\ncontent-type: text/html; charset=utf-8\n...\n\n# git clone 테스트\ngit clone https://github.com/username/repository\n\n# 패키지 설치 테스트\nsudo apt update\nsudo apt install net-tools\n```\n\n## 🔧 추가 트러블슈팅\n\n### 게이트웨이 Ping이 실패하는 경우\n\n많은 라우터는 보안상 ICMP ping을 차단합니다. 따라서 게이트웨이 ping이 실패하더라도 실제 인터넷 연결은 정상일 수 있습니다.\n\n```bash\n# ping 대신 실제 연결 테스트\ncurl -I https://google.com\nwget --spider https://google.com\n```\n\n### VPN 사용 시\n\n일부 VPN 소프트웨어가 WSL 네트워킹을 방해할 수 있습니다:\n\n1. VPN 연결 해제 후 테스트\n2. VPN 설정에서 \"로컬 네트워크 허용\" 옵션 활성화\n3. WSL 트래픽을 VPN 터널에서 제외\n\n### Hyper-V 가상 스위치 재생성\n\n극단적인 경우 가상 스위치를 수동으로 재생성:\n\n```powershell\n# PowerShell (관리자)\nwsl --shutdown\nGet-VMSwitch\nRemove-VMSwitch \"WSL\" -Force\n```\n\nWSL 재시작 시 자동으로 가상 스위치가 재생성됩니다.\n\n## 📋 완전한 해결 체크리스트\n\n1. ✅ Windows 네트워크 스택 재설정\n   ```powershell\n   netsh winsock reset\n   netsh int ip reset\n   ```\n\n2. ✅ `.wslconfig`에 mirrored 네트워크 모드 설정\n   ```ini\n   [wsl2]\n   networkingMode=mirrored\n   ```\n\n3. ✅ Windows 재부팅\n\n4. ✅ `/etc/wsl.conf`에서 자동 DNS 비활성화\n   ```ini\n   [network]\n   generateResolvConf = false\n   ```\n\n5. ✅ `/etc/resolv.conf` 수동 설정\n   ```bash\n   sudo rm /etc/resolv.conf\n   sudo bash -c 'echo \"nameserver 8.8.8.8\" > /etc/resolv.conf'\n   ```\n\n6. ✅ WSL 재시작 및 연결 테스트\n   ```powershell\n   wsl --shutdown\n   ```\n\n## 🎓 핵심 요약\n\n**문제의 본질:**\n- WSL2가 자체 가상 네트워크에 격리되어 Windows 호스트 네트워크와 브릿지 실패\n- systemd-resolved의 DNS stub resolver가 실제 DNS 서버와 통신 불가\n\n**해결의 핵심:**\n1. **Mirrored 네트워크 모드**: WSL이 Windows 네트워크를 직접 사용하도록 변경\n2. **수동 DNS 설정**: systemd-resolved 대신 직접 DNS 서버 지정\n\n**예방 방법:**\n- `.wslconfig`와 `/etc/wsl.conf`를 미리 설정\n- VPN 사용 시 WSL 호환성 확인\n- Windows 네트워크 변경 시 WSL 재시작\n\n## 💡 참고 자료\n\n- [Microsoft WSL Documentation](https://learn.microsoft.com/en-us/windows/wsl/)\n- [WSL2 Networking](https://learn.microsoft.com/en-us/windows/wsl/networking)\n- [systemd-resolved](https://www.freedesktop.org/software/systemd/man/systemd-resolved.service.html)\n\n---\n\n이 가이드로 동일한 문제를 겪는 분들에게 도움이 되길 바랍니다! 🚀"},{"excerpt":"🚀 들어가며 NeoVim을 설치했으니 이제 나만의 configuration을 시작해볼 차례다. 가장 기본이 되는 플러그인 매니저 설치부터 시작한다. 💪 NeoVim이 처음 나왔을 때에 주로 사용되던 매니저는 이다. 이전의 Vundle이나 Pathogen 같은 매니저들보다 훨씬 단순하고 설정이 간편했지만 VimScript 기반이라는 한계가 있었다. NeoV…","fields":{"slug":"/neovim-install-lazy/"},"frontmatter":{"date":"October 30, 2025","title":"[NeoVim] Lazy.nvim 플러그인 매니저와 파일 트리 설치","tags":["neovim","ide"]},"rawMarkdownBody":"\n## 🚀 들어가며\n\nNeoVim을 설치했으니 이제 나만의 configuration을 시작해볼 차례다. 가장 기본이 되는 플러그인 매니저 설치부터 시작한다. 💪\n\nNeoVim이 처음 나왔을 때에 주로 사용되던 매니저는 `vim-plug`이다. 이전의 Vundle이나 Pathogen 같은 매니저들보다 훨씬 단순하고 설정이 간편했지만 VimScript 기반이라는 한계가 있었다.\n\nNeoVim의 Lua 지원을 활용하기 위해 개발된 것이 `packer`이다. Lua는 Vimscript보다 빠르고 효율적이며, 현대적인 프로그래밍 언어의 기능들을 제공한다.\n\n요즘 보편적으로 사용하는 플러그인 매니저는 `lazy.nvim`이다. 코드가 간결하고 이해하기 쉬우며, 지연 로딩(lazy loading) 최적화로 매우 빠른 실행 속도를 자랑한다.\n\n## 🔌 Lazy.nvim 설치\n\n### 초기 설치 코드 작성\n\nKickstart의 `init.lua` 파일에서 다음 부분을 복사헤, 나의 `init.lua`에 붙여넣기한다. Line 200 초중반에 있고, `lazy` 키워드로 검색하면 편하다.\n\n```lua\n-- [[ Install `lazy.nvim` plugin manager ]]\n--    See `:help lazy.nvim.txt` or https://github.com/folke/lazy.nvim for more info\nlocal lazypath = vim.fn.stdpath 'data' .. '/lazy/lazy.nvim'\nif not (vim.uv or vim.loop).fs_stat(lazypath) then\n  local lazyrepo = 'https://github.com/folke/lazy.nvim.git'\n  local out = vim.fn.system { 'git', 'clone', '--filter=blob:none', '--branch=stable', lazyrepo, lazypath }\n  if vim.v.shell_error ~= 0 then\n    error('Error cloning lazy.nvim:\\n' .. out)\n  end\nend\n\n---@type vim.Option\nlocal rtp = vim.opt.rtp\nrtp:prepend(lazypath)\n\n-- [[ Configure and install plugins ]]\n--\n--  To check the current status of your plugins, run\n--    :Lazy\n--\n--  You can press `?` in this menu for help. Use `:q` to close the window\n--\n--  To update plugins you can run\n--    :Lazy update\n--\n-- NOTE: Here is where you install your plugins.\nrequire('lazy').setup({\n```\n\n주석은 최소한으로 남기고 지우는 것을 권장한다.\n\n```lua\n-- [[ init.lua ]]\n\n-- [[ Install `lazy.nvim` plugin manager ]]\nlocal lazypath = vim.fn.stdpath 'data' .. '/lazy/lazy.nvim'\nif not (vim.uv or vim.loop).fs_stat(lazypath) then\n  local lazyrepo = 'https://github.com/folke/lazy.nvim.git'\n  local out = vim.fn.system { 'git', 'clone', '--filter=blob:none', '--branch=stable', lazyrepo, lazypath }\n  if vim.v.shell_error ~= 0 then\n    error('Error cloning lazy.nvim:\\n' .. out)\n  end\nend\n\n---@type vim.Option\nlocal rtp = vim.opt.rtp\nrtp:prepend(lazypath)\n\n-- [[ Configure and install plugins ]]\nrequire('lazy').setup('plugins')\n```\n\n### 플러그인 설치 방식\n\n플러그인 설치 코드를 작성하는 방법은 두 가지가 있다.\n\n1. `plugins` 폴더에 있는 모든 플러그인을 무조건 설치한다.\n\n플러그인은 `lua/plugins/` 폴더에서 관리한다. 다음과 같이 코드를 작성하면 해당 폴더의 모든 플러그인이 항상 설치된다.\n\n```lua\nrequire('lazy').setup('plugins')\n```\n\n2. 설치할 플러그인을 명시적으로 설정한다.\n\n플러그인 폴더에서 원하는 플러그인들을 직접 작성한다. \n\n사용하지 않는 플러그인을 삭제하지 않고 백업용으로 둘 수 있다는 장점이 있는 반면에, 새로운 플러그인을 추가할 때는 다소 귀찮다는 단점이 있다. 나는 1번 방법으로 하고 있다.\n\n```lua\nrequire('lazy').setup({\n  require 'plugins.telescope',\n  require 'plugins.treesitter',\n})\n```\n\n## 📂 파일 트리 설치\n\n첫 플러그인으로 파일 트리 중 하나인 [neo-tree(클릭)](https://github.com/nvim-neo-tree/neo-tree.nvim) 플러그인을 설치한다. 파일 트리 플러그인에는 neo-tree와 nvim-tree가 제일 많이 사용되는데, neo-tree가 더 현대적인 기능이 많다.\n\n```lua\n-- [[ lua/plugins/neotree.lua ]]\n\nreturn {\n  {\n    \"nvim-neo-tree/neo-tree.nvim\",\n    branch = \"v3.x\",\n    dependencies = {\n      \"nvim-lua/plenary.nvim\",\n      \"MunifTanjim/nui.nvim\",\n      \"nvim-tree/nvim-web-devicons\", -- optional, but recommended\n    },\n    lazy = false, -- neo-tree will lazily load itself\n  }\n}\n```\n\n위와 같이 `neotree.lua` 파일을 작성하고 NeoVim을 다시 실행하면 플러그인이 설치된다.\n\n![neo-tree](image.png)\n\n`:Neotree` 명령어로 파일 트리를 켜고, `:Neotree close`로 닫을 수 있다.\n\n![Create new file](image-1.png)\n\n폴더에 포커스가 주어진 상태에서 `a`키를 누르면 새로운 파일이나 디렉토리를 만들 수 있다. 이름을 입력하고 마지막에 슬래시(`/`)를 붙이면 디렉토리가 생성된다.\n\n## ✨ 마치며\n\n처음 Neo-tree를 설치하면 파일 앞 아이콘이 깨져 보일 수 있다. 터미널 설정 폰트가 아이콘을 지원하지 않기 때문인데, 이는 `nerd font`를 설치하면 해결 가능하다.\n\n다음 포스트에서 폰트 설정을 포함해 기본 UI 설정을 다룰 예정이다."},{"excerpt":"🚀 들어가며 본 포스트는 NeoVim 설치 과정과 간단한 configuration을 담고 있습니다. 여기서 진행하는 설정은 모두 리셋하고 다시 personal config를 셋업할 예정이니 참고하시기 바랍니다. 여러 환경 문제로 VSCode를 사용할 수 없는 난관에 빠졌다.. 개발을 하면서 GUI를 사용할 수 없다니.. 말도 안 돼 😱😱 되는 대로 vim…","fields":{"slug":"/neovim-start/"},"frontmatter":{"date":"October 29, 2025","title":"[NeoVim] NeoVim 설치 및 맛보기","tags":["neovim","ide"]},"rawMarkdownBody":"\n## 🚀 들어가며\n\n본 포스트는 NeoVim 설치 과정과 간단한 configuration을 담고 있습니다. 여기서 진행하는 설정은 모두 리셋하고 다시 personal config를 셋업할 예정이니 참고하시기 바랍니다.\n\n---\n\n<br>\n\n여러 환경 문제로 VSCode를 사용할 수 없는 난관에 빠졌다.. 개발을 하면서 GUI를 사용할 수 없다니.. 말도 안 돼 😱😱 \n\n되는 대로 vim 에디터를 쓰다가 생산성이 너무 떨어져 대안에 찾아 나섰다. 그렇게 추천받은 에디터가 CUI를 사용하는 NeoVim이다. \n\n처음에는 예쁜 디자인에 끌려 NvChad 디스트로를 설치해 사용해 보았는데, 이미 모든 configuration이 완성되어 있다 보니 나에게 익숙하지 않은 키맵이 너무 많아 그냥 raw vim을 쓰는 것과 크게 다르지 않게 느껴졌다.\n\n나에게 익숙한 건 단연 VSCode. NeoVim을 VSCode 및 윈도우 환경과 최대한 비슷하게 구축하는 것을 목표로 삼고, [유튜브 영상(클릭)](https://youtu.be/KYDG3AHgYEs?si=zX4IFnZvH9rJVbW7)을 참고해 커스터마이징을 시작했다!\n\n`NeoVim으로 개발환경 구축하기` 시리즈에서는 위 영상을 일부 번역하는 동시에 나의 개인 설정을 기록하려 한다. 영상이 매우 잘 설명되어 있어서, 혹시 이 게시물을 참고한다면 영상 또한 시청하는 것을 권장한다.\n\n## 📥 NeoVim 최신 Release 다운로드\n\n### 우분투 패키지 다운로드\n\n우분투 패키지 매니저에서 다운로드받을 수 있다. 다만 내가 했을 때는 v0.6.1이 다운로드되는 불상사가 발생했다. 😅\n\n최신 NeoVim은 v0.11.x이며 deprecated된 요소들이 있으므로, 다음 목차에서 소스 코드로 다운로드받는 것을 권장한다.\n\n```bash\nsudo apt update\nsudo apt install neovim\nnvim --version\n```\n\n```\nNVIM v0.6.1\nBuild type: Release\nLuaJIT 2.1.0-beta3\nCompiled by team+vim@tracker.debian.org\n\nFeatures: +acl +iconv +tui\nSee \":help feature-compile\"\n\n   system vimrc file: \"$VIM/sysinit.vim\"\n  fall-back for $VIM: \"/usr/share/nvim\"\n\nRun :checkhealth for more info\n```\n\n### 소스 코드로부터 다운로드\n\n[NeoVim Release(클릭)](https://github.com/neovim/neovim/releases) 페이지에서 `nvim-linux-x86_64.tar.gz` 파일을 다운로드한다.\n\nappimage 파일 자체를 다운로드하는 방법과 압축 파일을 다운로드 하는 방법이 있는데, TAR 압축 파일을 해제하는 것이 더 전통적이다.\n\n```bash\ncd /usr/bin/\n# Latest stable release가 업데이트되었다면 해당 파일을 다운로드한다.\n(sudo) wget https://github.com/neovim/neovim/releases/download/v0.11.4/nvim-linux-x86_64.tar.gz\n(sudo) tar xzvf nvim-linux-x86_64.tar.gz\n(sudo) rm nvim-linux-x86_64.tar.gz\necho \"PATH=/usr/bin/nvim-linux-x86_64/bin:$PATH\" >> ~/.bashrc\nsource ~/.bashrc\n```\n\n설치 이후 설정 커스텀을 위한 디렉토리를 생성하고, PATH 정상 등록과 NeoVim 버전을 확인한다.\n\n```bash\nmkdir -p ~/.config/nvim\ncd ~/.config/nvim\nwhich nvim\nnvim --version\n```\n\n## 👀 NeoVim custom config 맛보기\n\n맛보기 부분은 추후 모두 삭제(`rm -rf`)하고 다시 설정을 진행하게 되니 참고용으로만 활용하면 된다.\n\n### `init.lua` 생성\n\nNeoVim의 커스텀 설정은 `~/.config/nvim` 디렉토리에서 이루어지며, 시작점은 `init.lua` 파일이다.\n\n```bash\ncd ~/.config/nvim\ntouch init.lua\nnvim init.lua\n```\n\n```lua\n-- [[ init.lua ]]\n\n-- Enable line number\nvim.wo.number = true\n```\n\n`vim.wo.number`는 vim의 `:set number`와 같은 기능을 하는 설정이다. 이를 저장하고 다시 `nvim` 명령어를 실행하면 사진과 같이 라인 넘버가 나타난다.\n\n![init.lua](image.png)\n\n### 개인 설정을 `options.lua`에서 설정하기\n\n`vim.wo.number`와 같은 설정들을 `options.lua` 파일에 한 데 모아 관리할 수 있다. `init.lua`는 프로그램의 시작점이므로 개인 옵션들은 따로 파일로 빼는 것이 바람직하다.\n\n```bash\ncd ~/.config/nvim\nmkdir lua\ncd lua\ntouch options.lua\nnvim options.lua\n```\n\n```lua\n-- [[ init.lua ]]\n\nrequire 'options'\n```\n\n```lua\n-- [[ lua/options.lua ]]\n\n-- Enable line number\nvim.wo.number = true\n```\n\n이후 `nvim` 명령어를 입력하면 이전과 동일하게 라인 넘버가 나타난다.\n\n## ⚡ `kickstart.nvim`으로 플러그인 맛보기\n\n`kickstart.nvim`은 NeoVim 커스터마이징의 시작점을 제공하며, LSP 등 복잡한 코드를 요구하는 설정들이 매우 잘 구현되어 있어 참고하기에 좋다. 이후 몇몇 플러그인을 설치할 때 kickstart를 참고할 예정이다.\n\n### Kickstart 시작하기\n\n`nvim` 디렉토리를 삭제하고 `kickstart.nvim`을 클론해서 살펴본다. 이 또한 추후 삭제하게 된다.\n\n```bash\ncd ~/.config\nrm -rf nvim\ngit clone https://github.com/nvim-lua/kickstart.nvim.git nvim\ncd nvim\nnvim init.lua\n```\n\n![lazy.nvim](image-1.png)\n\nNeoVim을 실행하면 사진과 같이 플러그인들이 설치된다. 이때 플러그인 매니저는 `lazy.nvim`을 사용하게 된다. 이전까지 사용되던 매니저는 `vim.plug`나 `packer`였는데, 코드나 구조가 다소 복잡해 대안으로 개발된 프로그램이 `lazy.nvim`이고, 이제는 가장 보편적으로 사용되고 있다.\n\n위 사진에 보이는 화면이 `lazy.nvim`의 플러그인 매니저 창이고, `:Lazy` 명령어로 켤 수 있다.\n\n![init.lua](image-2.png)\n\n`q` 버튼으로 `lazy`의 창을 닫으면 위 사진과 같은 주석과 함께 `init.lua` 파일이 보이게 된다. \n\nkickstart는 특정 배포 버전이 아니라 개인 설정을 위한 시작점을 제공한다는 내용으로 시작하며, 이 `init.lua` 파일의 각종 주석을 잘 읽으면 굉장한 인사이트를 얻을 수 있다! 👻\n\n### 플러그인 추가하기\n\n`init.lua` 파일의 Line 900 중반에 파일 트리 플러그인을 추가할 수 있도록 하는 주석이 있다. 이를 주석 해제한다.\n\n```lua\n-- other plugins..\nrequire 'kickstart.plugins.neo-tree',\n-- other plugins..\n```\n\n저장하고 NeoVim을 재시작하면 플러그인이 설치된다. kickstart의 파일 트리 토글 버튼은 `/`(백슬래시)로, 백슬래시를 누르면 파일 트리가 열린다.\n\n![neo-tree](image-3.png)\n\n파일 트리 플러그인 추가 코드에서 조금 더 밑으로 내려가면 커스텀 플러그인을 import할 수 있는 코드가 있다. 여기를 주석 해제하면 `lua/custom/plugins` 디렉토리에 있는 모든 플러그인이 설치된다.\n\n```lua\n-- { import = 'custom.plugins' },\n```\n\n## ✨ 마치며\n\n이제 진짜 custom config를 위해 kickstart도 지워주면 된다. 추후에 코드를 참고하기 위해 다른 디렉토리로 옮겨도 무방한데, 나는 github에서 바로바로 보는 게 편해서 아예 지워 버렸다.\n\nNeoVim을 설정하면서 느낀 건, 설정하는 데는 시간이 좀 걸리지만 확실히 편하다! 나는 맥이랑 윈도우를 모두 사용하는데, 단축키를 내 마음대로 설정할 수 있다 보니 맥/윈도우 단축키 중 내가 편하다고 느끼는 것들을 모두 NeoVim에 이식했다.\n\n확실히 개발자는.. 이런 게 제일 재밌는 것 같다 ㅎㅎ"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}